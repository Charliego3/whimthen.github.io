<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://whimthen.github.io</id>
    <title>Little</title>
    <updated>2020-03-30T03:14:00.592Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://whimthen.github.io"/>
    <link rel="self" href="https://whimthen.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://whimthen.github.io/images/avatar.png</logo>
    <icon>https://whimthen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Little</rights>
    <entry>
        <title type="html"><![CDATA[1.2.6 - Go: 最佳实践(方法)]]></title>
        <id>https://whimthen.github.io/post/sE2LRGZym/</id>
        <link href="https://whimthen.github.io/post/sE2LRGZym/">
        </link>
        <updated>2020-03-30T03:13:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="指针和值">指针和值</h1>
<p>正如我们在ByteSize上看到的那样，可以为任何命名类型(指针或接口除外)定义方法。接收者不必是结构。</p>
<p>在上面的切片讨论中，我们编写了一个Append函数。我们可以将其定义为切片的方法。为此，我们首先声明一个可以绑定该方法的命名类型，然后使该方法的接收者成为该类型的值。</p>
<pre><code class="language-go">type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Body exactly the same as the Append function defined above.
}
</code></pre>
<p>这仍然需要方法返回更新的切片。我们可以通过重新定义该方法以将指向ByteSlice的指针作为其接收方来消除这种笨拙，因此该方法可以覆盖调用方的切片。</p>
<pre><code class="language-go">func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Body as above, without the return.
    *p = slice
}
</code></pre>
<p>实际上，我们可以做得更好。如果我们修改函数，使其看起来像是一个标准的<code>Write</code>方法，就像这样，</p>
<pre><code class="language-go">func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Again as above.
    *p = slice
    return len(data), nil
}
</code></pre>
<p>则<code>*ByteSlice</code>类型满足标准接口<code>io.Writer</code>，这很方便。例如，我们可以打印成一个。</p>
<pre><code class="language-go">var b ByteSlice
fmt.Fprintf(&amp;b, &quot;This hour has %d days\n&quot;, 7)
</code></pre>
<p>我们传递<code>ByteSlice</code>的地址，因为只有<code>*ByteSlice</code>满足<code>io.Writer</code>。关于指针与接收器的值的规则是，可以在指针和值上调用值方法，但只能在指针上调用指针方法。</p>
<p>之所以出现此规则，是因为指针方法可以修改接收者。在一个值上调用它们将导致该方法接收该值的副本，因此任何修改将被丢弃。因此，该语言不允许出现此错误。当值是可寻址时，该语言将通过自动插入地址运算符来处理在值上调用指针方法的常见情况。在我们的示例中，变量b是可寻址的，因此我们可以仅使用<code>b.Write</code>调用其<code>Write</code>方法。编译器会将其重写为<code>(&amp;b).Write</code>。</p>
<p>顺便说一句，在字节的一部分上使用<code>Write</code>的想法对于<code>bytes.Buffer</code>的实现至关重要。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2.5 - Go: 最佳实践(初始化)]]></title>
        <id>https://whimthen.github.io/post/6phOW9Yw8/</id>
        <link href="https://whimthen.github.io/post/6phOW9Yw8/">
        </link>
        <updated>2020-03-29T08:45:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>从表面上看，Go与C或C++中的初始化没有太大区别，但是Go中的初始化功能更强大。可以在初始化期间构建复杂的结构，并且正确处理了初始化对象之间的排序问题，甚至可以处理不同的包之间的排序问题。</p>
<h1 id="常量">常量</h1>
<p>Go中的常量就是值不变的变量。即使在函数中定义为局部变量时，也可以在编译时创建它们，并且只能是数字，字符，字符串或布尔值。由于编译时的限制，定义它们的表达式必须是可由编译器评估的常量表达式。例如，<code>1&lt;&lt;3</code>是常量表达式，而<code>math.Sin(math.Pi / 4)</code>并不是因为对<code>math.Sin</code>的函数调用需要在运行时发生。</p>
<p>在Go中，使用<code>iota</code>枚举器创建枚举常量。由于iota可以是表达式的一部分，并且表达式可以隐式重复，因此可以轻松构建复杂的值集。</p>
<pre><code class="language-go">type ByteSize float64

const (
    _           = iota // ignore first value by assigning to blank identifier
    KB ByteSize = 1 &lt;&lt; (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
</code></pre>
<p>将诸如String之类的方法附加到任何用户定义的类型的能力使得任意值都可以自动格式化自身以进行打印。尽管您会看到它最常用于结构，但该技术对于标量类型(如ByteSize之类的浮点类型)也很有用。</p>
<pre><code class="language-go">func (b ByteSize) String() string {
    switch {
    case b &gt;= YB:
        return fmt.Sprintf(&quot;%.2fYB&quot;, b/YB)
    case b &gt;= ZB:
        return fmt.Sprintf(&quot;%.2fZB&quot;, b/ZB)
    case b &gt;= EB:
        return fmt.Sprintf(&quot;%.2fEB&quot;, b/EB)
    case b &gt;= PB:
        return fmt.Sprintf(&quot;%.2fPB&quot;, b/PB)
    case b &gt;= TB:
        return fmt.Sprintf(&quot;%.2fTB&quot;, b/TB)
    case b &gt;= GB:
        return fmt.Sprintf(&quot;%.2fGB&quot;, b/GB)
    case b &gt;= MB:
        return fmt.Sprintf(&quot;%.2fMB&quot;, b/MB)
    case b &gt;= KB:
        return fmt.Sprintf(&quot;%.2fKB&quot;, b/KB)
    }
    return fmt.Sprintf(&quot;%.2fB&quot;, b)
}
</code></pre>
<p>表达式YB打印为1.00YB，而<code>ByteSize(1e13)</code>打印为9.09TB。<br>
在这里使用<code>Sprintf</code>来实现<code>ByteSize</code>的String方法是安全的（避免无限期地重复），不是因为发生转换，而是因为它使用<code>%f</code>调用了<code>Sprintf</code>，它不是字符串格式：<code>Sprintf</code>仅在需要字符串时才调用<code>String</code>方法，<code>%f</code>需要一个浮点值。</p>
<h1 id="变量">变量</h1>
<p>变量可以像常量一样被初始化，但是初始化器可以是在运行时计算的通用表达式。</p>
<pre><code class="language-go">var (
    home   = os.Getenv(&quot;HOME&quot;)
    user   = os.Getenv(&quot;USER&quot;)
    gopath = os.Getenv(&quot;GOPATH&quot;)
)
</code></pre>
<h1 id="初始化函数init">初始化函数(init)</h1>
<p>最后，每个源文件都可以定义自己的无参数函数(<code>init</code>)来设置所需的任何状态。(实际上，每个文件可以具有多个<code>ini</code>t函数。)意味着：在程序包中的所有变量声明评估了其初始化程序之后，才调用init，并且只有在所有导入的程序包都被初始化之后才对init进行评估。</p>
<p>除了不能表示为声明的初始化外，init函数的常见用法是在实际执行开始之前验证或修复程序状态的正确性。</p>
<pre><code class="language-go">func init() {
    if user == &quot;&quot; {
        log.Fatal(&quot;$USER not set&quot;)
    }
    if home == &quot;&quot; {
        home = &quot;/home/&quot; + user
    }
    if gopath == &quot;&quot; {
        gopath = home + &quot;/go&quot;
    }
    // gopath may be overridden by --gopath flag on command line.
    flag.StringVar(&amp;gopath, &quot;gopath&quot;, gopath, &quot;override default GOPATH&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2.4 - Go: 最佳实践(内建函数、数据结构)]]></title>
        <id>https://whimthen.github.io/post/cmK5xcYzD/</id>
        <link href="https://whimthen.github.io/post/cmK5xcYzD/">
        </link>
        <updated>2020-03-28T02:37:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>Go中有两个分配语句。内置函数<code>new</code>和<code>make</code>。它们执行不同的操作并应用于不同的类型，这可能会令人困惑，但是规则很简单。</p>
<h1 id="使用new分配内存">使用<code>new</code>分配内存</h1>
<p>这是一个分配内存的内置函数，但与其他语言中的同名函数不同，它不会初始化内存，只会将其清零。也就是说，<code>new(T)</code>为类型<code>T</code>的新项目分配零存储空间，并返回其地址，即类型<code>*T</code>的值。在Go术语中，它返回一个指向新分配的<code>T</code>类型零值的指针。</p>
<p>由于new返回的内存为零，因此在设计数据结构时安排使用每种类型的零值而无需进一步初始化将很有帮助。这意味着用户可以使用<code>new</code>创建一个数据结构并开始工作。例如，<code>bytes.Buffer</code>的文档指出“Buffer的零值是准备使用的空缓冲区”。同样，<code>sync.Mutex</code>没有显式构造函数或Init方法。而是将<code>sync.Mutex</code>的零值定义为未锁定的互斥锁。</p>
<p>零值属性在工作中很有用。例如如下类型定义:</p>
<pre><code class="language-go">type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
</code></pre>
<p><code>SyncedBuffer</code>类型的值也可以在分配后或声明后立即使用。在下一个代码段中，<code>p</code>和<code>v</code>都可以正常使用，而无需进一步分配。</p>
<pre><code class="language-go">p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
</code></pre>
<h1 id="构造函数和a-hrefcompositeliteral复合字面量asup1sup">构造函数和<a href="#compositeLiteral">复合字面量</a><sup>1</sup></h1>
<p>有时零值不够好，因此需要初始化构造函数，如下例中从包<code>os</code>派生的那样。</p>
<pre><code class="language-go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</code></pre>
<p>我们可以使用复合字面量来简化它，该字面量是在每次求值时都会创建一个新实例的表达式。</p>
<pre><code class="language-go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f
}
</code></pre>
<p>注意，与C语言不同，返回局部变量的地址是完全可以的。函数返回后，与变量关联的存储将保留。实际上，采用复合字面量的地址会在每次对其求值时分配一个新实例，因此我们可以将最后两行结合在一起。</p>
<pre><code class="language-go">return &amp;File{fd, name, nil, 0}
</code></pre>
<p>复合字面量的字段按顺序排列，并且必须全部存在。但是，通过将元素显式标记为<code>field: value</code>对，初始化器可以按任意顺序出现，而缺失的字段则保留为各自的零值。因此我们可以修改为:</p>
<pre><code class="language-go">return &amp;File{fd: fd, name: name}
</code></pre>
<p>在特殊情况下，如果一个复合文字完全不包含任何字段，它将为该类型创建一个零值。表达式<code>new(File)</code>和<code>&amp;File {}</code>是等效的。</p>
<p>也可以为数组，切片和映射创建复合字面量，其中字段标签为索引或映射键。在这些示例中，无论<code>Enone</code>，<code>Eio</code>和<code>Einval</code>的值是什么，初始化都可以工作，只要它们是不同的即可。</p>
<pre><code class="language-go">a := [...]string   {Enone: &quot;no error&quot;, Eio: &quot;Eio&quot;, Einval: &quot;invalid argument&quot;}
s := []string      {Enone: &quot;no error&quot;, Eio: &quot;Eio&quot;, Einval: &quot;invalid argument&quot;}
m := map[int]string{Enone: &quot;no error&quot;, Eio: &quot;Eio&quot;, Einval: &quot;invalid argument&quot;}
</code></pre>
<blockquote>
<p><span id="compositeLiteral">1. 复合字面量: 关于Go中的复合字面量更多的解释可以<a href="https://studygolang.com/articles/12913">查看</a> </span></p>
</blockquote>
<h1 id="使用make分配内存">使用<code>make</code>分配内存</h1>
<p>内置函数<code>make(T, args)</code>的目的不同于<code>new(T)</code>。它仅创建<code>slice</code>，<code>map</code>和<code>channel</code>，并且返回类型<code>T</code>(不是<code>*T</code>)的初始化值(未归零)。区别的原因是这三种类型在底层表示了对在使用之前必须初始化的数据结构的引用。例如，切片是一个三项描述符，其中包含指向数据(数组内部)，长度和容量的指针，在初始化这些之前，切片为<code>nil</code>。对于<code>slice</code>，<code>map</code>和<code>channel</code>，<code>make</code>初始化内部数据结构并准备要使用的值。例如:</p>
<pre><code class="language-go">make([]int, 10, 100)
</code></pre>
<p>分配一个100个整数的数组，然后创建一个长度为10，容量为100的切片结构，指向该数组的前10个元素。(创建切片时，可以省略容量；有关更多信息，请参见切片部分。)相比之下，<code>new([]int)</code>返回指向新分配的零切片结构的指针，也就是说，指向<code>nil</code>切片值的指针。</p>
<p>这些示例说明了<code>new</code>和<code>make</code>之间的区别。</p>
<pre><code class="language-go">var p *[]int = new([]int)       // 分配切片; *p == nil; 很少用
var v  []int = make([]int, 100) // 切片v现在引用一个包含100个整数的新数组

// 不必要，过于复杂:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// 常用方式:
v := make([]int, 100)
</code></pre>
<p>请记住，<code>make</code>仅适用于<code>slice</code>，<code>map</code>和<code>channel</code>，不会返回指针。要获得显式指针，请使用new分配或显式获取变量的地址。</p>
<h1 id="数组">数组</h1>
<p>数组在计划内存的详细布局时很有用，有时可以避免分配。<br>
在Go和C中，数组的工作方式之间存在主要差异。在Go中:</p>
<ul>
<li>数组是值。将一个数组分配给另一个数组将复制所有元素。</li>
<li>特别是，如果将数组传递给函数，它将接收该数组的副本，而不是指向该数组的指针。</li>
<li>数组的大小是其类型的一部分。类型<code>[10]int</code>和<code>[20]int</code>是不同的。</li>
</ul>
<p>数组值既有用又有更大的代价。如果您想要类C的行为和效率，可以将指针传递给数组。</p>
<pre><code class="language-go">func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // Note the explicit address-of operator
</code></pre>
<p>但是，这种风格不是惯用的。请改用切片。</p>
<h1 id="切片">切片</h1>
<p>切片包装数组可为数据序列提供更通用，更强大和更方便的接口。除了具有明确维数的项(例如转换矩阵)外，Go中的大多数数组编程都是使用切片而不是简单数组完成的。</p>
<p>切片包含对基础数组的引用，如果您将一个切片分配给另一个切片，则它们都引用同一数组。如果函数采用<code>slice</code>参数，则对<code>slice</code>的元素所做的更改将对调用者可见，这类似于将指针传递给基础数组。因此，<code>Read</code>函数可以接受切片参数，而不是指针和大小。切片内的长度设置了要读取多少数据的上限。这是包os中File类型的Read方法的签名:</p>
<pre><code class="language-go">func (f *File) Read(buf []byte) (n int, err error)
</code></pre>
<p>该方法返回读取的字节数和错误值(如果有)。要读入较大缓冲区buf的前32个字节，请对缓冲区进行切片(动作)。</p>
<pre><code class="language-go">n, err := f.Read(buf[0:32])
</code></pre>
<p>这种切片是普通且有效的。实际上，暂时不考虑效率，以下代码段还将读取缓冲区的前32个字节。</p>
<pre><code class="language-go">var n int
var err error
for i := 0; i &lt; 32; i++ {
    nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
    n += nbytes
    if nbytes == 0 || e != nil {
        err = e
        break
    }
}
</code></pre>
<p>切片的长度可以更改，只要它仍然适合基础数组的限制即可；只需将其分配给自身的一部分即可。切片的<code>capacity</code>容量:可通过内置函数<code>cap(slice)</code>获取, 反映了切片可能采用的最大长度。这是将数据追加到切片的函数。如果数据超出容量，则会重新分配。返回结果切片。该函数使用<code>len</code>和<code>cap</code>应用于<code>nil slice</code>时合法的事实，并返回<code>0</code>。</p>
<pre><code class="language-go">func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    copy(slice[l:], data)
    return slice
}
</code></pre>
<p>之后必须返回切片，因为尽管<code>Append</code>可以修改切片的元素，但切片本身(包含指针，长度和容量的运行时数据结构)是按值传递的。</p>
<p>通过内置函数<code>Append</code>追加到切片是非常有用的。</p>
<h1 id="二维切片">二维切片</h1>
<p>Go的数组和切片是一维的。要创建等效于2D数组或切片的数组，必须定义数组数组或切片切片，如下所示：</p>
<pre><code class="language-go">type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
</code></pre>
<p>由于切片的长度是可变的，因此有可能使每个内部切片的长度不同。这可能是常见的情况，如<code>LinesOfText</code>示例：每行都有独立的长度。</p>
<pre><code class="language-go">text := LinesOfText{
	[]byte(&quot;Now is the time&quot;),
	[]byte(&quot;for all good gophers&quot;),
	[]byte(&quot;to bring some fun to the party.&quot;),
}
</code></pre>
<p>有时有必要分配2D切片，例如，在处理像素的扫描线时可能会出现这种情况。有两种方法可以实现此目的。一种是独立分配每个切片；另一种是分配单个数组，并将单个切片指向该数组。使用哪种取决于您的应用程序。如果切片可能增大或缩小，则应独立分配它们，以免覆盖下一行；如果不是，则使用单一分配构造对象可能会更有效。作为参考，以下是这两种方法的示例。首先，一次一行：</p>
<pre><code class="language-go">// Allocate the top-level slice.
picture := make([][]uint8, YSize) // One row per unit of y.
// Loop over the rows, allocating the slice for each row.
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
</code></pre>
<p>另外一种分配，分成几行：</p>
<pre><code class="language-go">// Allocate the top-level slice, the same as before.
picture := make([][]uint8, YSize) // One row per unit of y.
// Allocate one large slice to hold all the pixels.
pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.
// Loop over the rows, slicing each row from the front of the remaining pixels slice.
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
</code></pre>
<h1 id="map">Map</h1>
<p>map是一种便捷而强大的内置数据结构，它将一种类型的值(键)与另一种类型的值(元素或值)相关联。键可以是定义了相等运算符的任何类型，例如整数，浮点数和复数，字符串，指针，接口(只要动态类型支持相等)，结构和数组。切片不能用作映射键，因为未定义相等性。像切片一样，map包含对基础数据结构的引用。如果将map作为参数传递，则更改将在调用方中可见。</p>
<p>可以使用带有冒号分隔的键/值对的常规复合文字语法来构建map，因此在初始化过程中轻松构建它们。</p>
<pre><code class="language-go">var timeZone = map[string]int{
    &quot;UTC&quot;:  0*60*60,
    &quot;EST&quot;: -5*60*60,
    &quot;CST&quot;: -6*60*60,
    &quot;MST&quot;: -7*60*60,
    &quot;PST&quot;: -8*60*60,
}
</code></pre>
<p>语法上分配和获取映射值看起来就像对数组和切片执行相同操作，只是索引不必是整数。</p>
<pre><code class="language-go">offset := timeZone[&quot;EST&quot;]
</code></pre>
<p>尝试使用map中不存在的键来获取值时，将返回值类型的零值。例如，如果map包含整数，则查找不存在的键将返回0。</p>
<pre><code class="language-go">attended := map[string]bool{
    &quot;Ann&quot;: true,
    &quot;Joe&quot;: true,
    ...
}

if attended[person] { // will be false if person is not in the map
    fmt.Println(person, &quot;was at the meeting&quot;)
}
</code></pre>
<p>有时，您需要将缺失的条目与零值区分开。是否存在”UTC”条目或0，因为它根本不在map中？您可以采用多种分配形式进行区分。</p>
<pre><code class="language-go">var seconds int
var ok bool
seconds, ok = timeZone[tz]
</code></pre>
<p>使用<code>, ok</code>语法可以判断map中是否存在<code>key</code>。下面的例子中，如果<code>tz</code>存在，<code>seconds</code>将被赋值并且<code>ok</code>为<code>true</code>，否则<code>seconds</code>将被设置为类型零值并且<code>ok</code>为<code>false</code>。</p>
<pre><code class="language-go">func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println(&quot;unknown time zone:&quot;, tz)
    return 0
}
</code></pre>
<p>要在map中测试是否存在而不必担心实际值，可以使用空白标识符(<code>_</code>)代替该值的常规变量。</p>
<pre><code class="language-go">_, present := timeZone[tz]
</code></pre>
<p>要删除map条目，请使用<code>delete</code>内置函数，其参数为地图和要删除的键。即使地图上已经没有<code>key</code>，也可以这样做。</p>
<pre><code class="language-go">delete(timeZone, &quot;PDT&quot;)  // Now on Standard Time
</code></pre>
<h1 id="输出printing">输出(Printing)</h1>
<p>Go中的格式化打印使用类似于C的<code>printf</code>系列的样式，但功能更丰富，更通用。这些函数位于<code>fmt</code>包中，并具有大写名称: <code>fmt.Printf</code>，<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code>等。字符串函数(<code>Sprintf</code>等)返回字符串，而不是填充提供的缓冲区。</p>
<p>你不需要提供格式字符串。对于每个<code>Printf</code>，<code>Fprintf</code>和<code>Sprintf</code>，还有另一对函数，例如<code>Print</code>和<code>Println</code>。这些函数不采用格式字符串，而是为每个参数生成默认格式。<code>Println</code>还会在参数之间插入一个空格，并在输出中添加换行符，而<code>Print</code>仅在两个操作数都不是字符串的情况下才添加空格。在此示例中，每行产生相同的输出。</p>
<pre><code class="language-go">fmt.Printf(&quot;Hello %d\n&quot;, 23)
fmt.Fprint(os.Stdout, &quot;Hello &quot;, 23, &quot;\n&quot;)
fmt.Println(&quot;Hello&quot;, 23)
fmt.Println(fmt.Sprint(&quot;Hello &quot;, 23))
</code></pre>
<p>格式化的打印函数<code>fmt.Fprint</code>将实现io.Writer接口的任何对象作为第一个参数；变量<code>os.Stdout</code>和<code>os.Stderr</code>是熟悉的实例。</p>
<p>这里的事情开始与C背道而驰。首先，诸如<code>％d</code>之类的数字格式不带有标志或大小的标志；相反，打印例程使用参数的类型来决定这些属性。</p>
<pre><code class="language-go">var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf(&quot;%d %x; %d %x\n&quot;, x, x, int64(x), int64(x))
</code></pre>
<p>输出结果:</p>
<pre><code class="language-shell">18446744073709551615 ffffffffffffffff; -1 -1
</code></pre>
<p>如果只需要默认转换(例如，十进制表示整数)，则可以使用<code>%v</code>(表示“值”)；结果正是<code>Print</code>和<code>Println</code>将产生的结果。而且，该格式可以打印任何值，甚至可以打印数组，切片，结构和映射。</p>
<pre><code class="language-go">fmt.Printf(&quot;%v\n&quot;, timeZone)  // or just fmt.Println(timeZone)
</code></pre>
<p>输出结果:</p>
<pre><code class="language-shell">map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]
</code></pre>
<p>对于map，<code>Printf</code>和其他格式化输出函数将按字母顺序对输出进行排序。</p>
<p>打印结构时，修改后的格式<code>%+v</code>用其名称注释结构的字段，对于任何值，备用格式<code>%#v</code>以完整的Go语法打印该值。</p>
<pre><code class="language-go">type T struct {
    a int
    b float64
    c string
}
t := &amp;T{ 7, -2.35, &quot;abc\tdef&quot; }
fmt.Printf(&quot;%v\n&quot;, t)
fmt.Printf(&quot;%+v\n&quot;, t)
fmt.Printf(&quot;%#v\n&quot;, t)
fmt.Printf(&quot;%#v\n&quot;, timeZone)
</code></pre>
<p>输出结果:</p>
<pre><code class="language-shell">&amp;{7 -2.35 abc   def}
&amp;{a:7 b:-2.35 c:abc     def}
&amp;main.T{a:7, b:-2.35, c:&quot;abc\tdef&quot;}
map[string]int{&quot;CST&quot;:-21600, &quot;EST&quot;:-18000, &quot;MST&quot;:-25200, &quot;PST&quot;:-28800, &quot;UTC&quot;:0}
</code></pre>
<p>(注意<code>&amp;</code>符号)当将引用的字符串格式应用于<code>string</code>类型或<code>[]byte</code>类型的值时，也可以通过<code>%q</code>获得。如果可能，备用格式<code>%#q</code>将使用反引号代替。(<code>%q</code>格式也适用于整数和字符，产生单引号的字符常数)。此外，<code>%x</code>可在字符串，字节数组和字节片以及整数上使用，生成一个长的十六进制字符串，并以(<code>%x</code>)格式的空格在字节之间放置空格。</p>
<p>另一个方便的格式是<code>%T</code>，它打印值的类型。</p>
<pre><code class="language-go">fmt.Printf(&quot;%T\n&quot;, timeZone)
</code></pre>
<p>输出结果:</p>
<pre><code class="language-shell">map[string]int
</code></pre>
<p>如果要控制自定义类型的默认格式，则所需要做的就是定义一个在类型上带有签名<code>String()</code>的方法。对于我们的简单类型<code>T</code>，可能看起来像这样。</p>
<pre><code class="language-go">func (t *T) String() string {
    return fmt.Sprintf(&quot;%d/%g/%q&quot;, t.a, t.b, t.c)
}
fmt.Printf(&quot;%v\n&quot;, t)
</code></pre>
<p>输出结果:</p>
<pre><code class="language-shell">7/-2.35/&quot;abc\tdef&quot;
</code></pre>
<p>（如果需要打印T类型的值以及指向T的指针，则String的接收者必须为值类型；此示例使用了一个指针，因为它对于结构类型更有效且更惯用。请参见下面的指针vs.值接收者以获取更多信息。）</p>
<p><code>String</code>方法能够调用<code>Sprintf</code>，因为打印例程是完全可重入的，并且可以通过这种方式包装。关于此方法，有一个重要的细节要理解：不要通过以无限期地重复使用String方法的方式调用Sprintf来构造String。如果Sprintf调用尝试将接收方直接打印为字符串，则可能会发生这种情况，而字符串又会再次调用该方法。如本例所示，这是一个常见且容易犯的错误。</p>
<pre><code class="language-go">type MyString string

func (m MyString) String() string {
    return fmt.Sprintf(&quot;MyString=%s&quot;, m) // Error: will recur forever.
}
</code></pre>
<p>也很容易解决：将参数转换为基本字符串类型，该类型没有方法。</p>
<pre><code class="language-go">type MyString string
func (m MyString) String() string {
    return fmt.Sprintf(&quot;MyString=%s&quot;, string(m)) // OK: note conversion.
}
</code></pre>
<p>在<a href="https://golang.org/doc/effective_go.html#initialization">初始化部分</a>，我们将看到另一种避免这种递归的技术。</p>
<p>另一种打印方式是将打印参数直接传递给另一个这样的函数。<code>Printf</code>的签名使用<code>...interface{}</code>类型作为其最后一个参数，以指定可以在格式之后显示任意数量的参数(任意类型)。</p>
<pre><code class="language-go">func Printf(format string, v ...interface{}) (n int, err error) {
</code></pre>
<p>在函数<code>Printf</code>中，<code>v</code>的作用类似于<code>[]interface{}</code>类型的变量，但如果将其传递给另一个可变参数的函数，则其作用类似于常规的参数列表。这是我们上面使用的函数<code>log.Println</code>的实现。它将其参数直接传递给<code>fmt.Sprintln</code>进行实际格式化。</p>
<pre><code class="language-go">// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
</code></pre>
<p>我们在<code>v</code>后面的<code>Sprintln</code>嵌套调用中编写<code>...</code>，以告诉编译器将v视为参数列表。否则它将仅将v作为单个slice参数传递。</p>
<p>顺便说一句，<code>...</code>参数可以是特定类型，例如<code>...int</code>用于选择最小整数列表的min函数:</p>
<pre><code class="language-go">func Min(a ...int) int {
    min := int(^uint(0) &gt;&gt; 1)  // largest int
    for _, i := range a {
        if i &lt; min {
            min = i
        }
    }
    return min
}
</code></pre>
<h1 id="追加append">追加(append)</h1>
<p>内置函数<code>append</code>的签名与上面定义的<code>Append</code>不同。签名是下面这样:</p>
<pre><code class="language-go">func append(slice []T, elements ...T) []T
</code></pre>
<p>其中<code>T</code>是任何给定类型的占位符。实际上无法在Go中编写一个由调用者确定类型T的函数。这就是内置append的原因：它需要编译器的支持。</p>
<p><code>append</code>操作是将元素附加到切片的末尾并返回结果。需要返回结果，因为与我们写的Append一样，底层数组可能会更改。这个简单的例子:</p>
<pre><code class="language-go">x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
</code></pre>
<p>打印<code>[1 2 3 4 5 6]</code>。因此，<code>append</code>的工作原理类似于<code>Printf</code>，它收集了任意数量的参数。</p>
<p>但是，如果我们要执行追加操作并将切片附加到切片，该怎么办？简单: 就像在上面对Output的调用中一样，在调用站点上使用<code>...</code>。此代码段产生与上面相同的输出。</p>
<pre><code class="language-go">x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
</code></pre>
<p>没有那个<code>...</code>，它将无法编译，因为类型将是错误的。<code>y</code>不是<code>int</code>类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2.3 - Go: 最佳实践(函数)]]></title>
        <id>https://whimthen.github.io/post/SDCTjJ1vS/</id>
        <link href="https://whimthen.github.io/post/SDCTjJ1vS/">
        </link>
        <updated>2020-03-26T03:38:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="多返回值">多返回值</h1>
<p>Go的不同寻常功能之一就是函数和方法可以有多个返回值。这种形式可用于改进C程序中的一些笨拙的习惯用法。</p>
<p>在C语言中，写入错误由负数表示，错误代码被隐藏在易失性位置中。在Go中<code>Write</code>可以返回一个<code>count</code>和一个<code>error</code>: &quot;Yes, you wrote some bytes but not all of them because you filled the device&quot;。<code>os</code>包中<code>Write</code>方法的签名为:</p>
<pre><code class="language-go">func (file *File) Write(b []byte) (n int, err error)
</code></pre>
<p>正如文档中所说，当<code>n != len(b)</code>时，返回写入的字节数和非<code>nil</code>的错误。这是一种常见的形式。有关更多示例，请参见错误处理部分。</p>
<p>类似的方法避免了将指针传递给返回值以模拟参考参数的需要。这是一个简单的函数，可从字节切片中的某个位置获取一个数字，然后返回该数字和下一个位置。</p>
<pre><code class="language-go">func nextInt(b []byte, i int) (int, int) {
    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
</code></pre>
<p>你可以用它来遍历接收的切片b:</p>
<pre><code class="language-go">for i := 0; i &lt; len(b); {
    x, i = nextInt(b, i)
    fmt.Println(x)
}
</code></pre>
<h1 id="结果参数命名返回值命名">结果参数命名(返回值命名)</h1>
<p>可以给Go函数的返回或结果“参数”指定名称，并将其用作常规变量，就像传入的参数一样。命名后，函数开始时会将它们初始化为零值。如果函数执行不带参数的<code>return</code>语句，则将结果参数的当前值用作返回值。</p>
<p>名称不是强制性的，但可以使代码更简短: 结果参数名称可以提高阅读性。如果我们命名nextInt的结果，则很清楚的就可以知道返回的int是什么含义。</p>
<pre><code class="language-go">func nextInt(b []byte, pos int) (value, nextPos int) {
</code></pre>
<p>由于命名结果参数被初始化为零值并绑定到返回值，因此它们既可以简化又可以说明含义。这是使用它们的<code>io.ReadFull</code>版本:</p>
<pre><code class="language-go">func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &gt; 0 &amp;&amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
</code></pre>
<h1 id="defer延迟">Defer(延迟)</h1>
<p>Go的<code>defer</code>语句调度一个函数调用(延迟函数)在执行延迟的函数返回之前立即执行。这是一种不寻常但有效的处理情况的方法，例如无论函数返回哪个路径都必须释放资源。典型的例子是解锁互斥锁或关闭文件。</p>
<pre><code class="language-go">// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return &quot;&quot;, err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return &quot;&quot;, err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
</code></pre>
<p>延迟执行对诸如<code>Close</code>之类的函数有两个优点:</p>
<ol>
<li>它保证了你永远不会忘记关闭文件，如果以后编辑函数以添加新的返回路径，则很容易犯此错误。</li>
<li>这意味着关闭位于打开处附近，这比将其放置在函数末尾清晰得多。</li>
</ol>
<p>延迟函数(如果函数是方法，则包括接收方)的参数在延迟执行时而不是在调用执行时进行评估。除了避免担心变量在函数执行时会更改值之外，这还意味着单个延迟的调用栈可以延迟多个函数的执行。<br>
这是一个愚蠢的例子:</p>
<pre><code class="language-go">for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}
</code></pre>
<p>延迟语句按(后进先出)<code>LIFO</code>顺序执行，因此该代码将在函数返回时导致打印<code>4 3 2 1 0</code>。一个更合理的示例是一种通过程序跟踪函数执行的简单方法。我们可以编写一些简单的跟踪例程，如下所示:</p>
<pre><code class="language-go">func trace(s string)   { fmt.Println(&quot;entering:&quot;, s) }
func untrace(s string) { fmt.Println(&quot;leaving:&quot;, s) }

// Use them like this:
func a() {
    trace(&quot;a&quot;)
    defer untrace(&quot;a&quot;)
    // do something....
}
</code></pre>
<p>我们可以利用以下事实来做得更好，即在执行延期时会评估延期函数的参数。跟踪例程可以将参数设置为取消跟踪例程。这个例子:</p>
<pre><code class="language-go">func trace(s string) string {
    fmt.Println(&quot;entering:&quot;, s)
    return s
}

func un(s string) {
    fmt.Println(&quot;leaving:&quot;, s)
}

func a() {
    defer un(trace(&quot;a&quot;))
    fmt.Println(&quot;in a&quot;)
}

func b() {
    defer un(trace(&quot;b&quot;))
    fmt.Println(&quot;in b&quot;)
    a()
}

func main() {
    b()
}
</code></pre>
<p>输出结果:</p>
<pre><code class="language-shell">entering: b
in b
entering: a
in a
leaving: a
leaving: b
</code></pre>
<p>对于习惯于使用其他语言进行块级资源管理的程序员来说，延迟似乎很奇怪，但是它最有趣，功能最强大的应用正是基于它不是基于块而是基于函数的事实。在<code>panic</code>和<code>recover</code>部分，我们将看到其可能性的另一个示例。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2.2 - Go: 最佳实践(流程控制)]]></title>
        <id>https://whimthen.github.io/post/pVvli46oS/</id>
        <link href="https://whimthen.github.io/post/pVvli46oS/">
        </link>
        <updated>2020-03-25T03:40:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Go的流程控制结构与C相关，但在重要方面有所不同。没有<code>do while</code>和<code>while</code>循环，只有<code>for</code>。<code>switch</code>很灵活。<code>if</code>和<code>switch</code>接受可选的初始化语句，像<code>for</code>一样。<code>break</code>和<code>continue</code>语句带有一个可选标签来标识要中断或继续的内容。包括了类型选择和多路复用选择器<code>select</code>。语法也略有不同：没有括号，并且主体必须始终用大括号分隔。</p>
</blockquote>
<h2 id="if">if</h2>
<p>在Go中，一个简单的if看起来像这样:</p>
<pre><code class="language-go">if x &gt; 0 {
    return y
}
</code></pre>
<p>在编写多行的<code>if</code>语句时必须使用括号。无论如何这样做都是好的风格，尤其是当主体包含控制语句(例如<code>return</code>或<code>break</code>)时。</p>
<p>由于<code>if</code>和<code>switch</code>接受初始化语句，因此通常会看到用来设置局部变量的语句。</p>
<pre><code class="language-go">if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</code></pre>
<p>在Go库中，当if语句不进入下一条语句时(即主体以<code>break</code>，<code>continue</code>，<code>goto</code>或<code>return</code>结尾)时，将省略不必要的<code>else</code>。</p>
<pre><code class="language-go">f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
</code></pre>
<p>这是一种常见情况的示例，在这种情况下，代码必须防止出现一系列错误情况。如果不进入if代码块，将向下继续执行，从而消除了出现错误的情况。由于错误一般以return语句结束，因此代码中不需要else语句。</p>
<pre><code class="language-go">f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
</code></pre>
<h2 id="重新声明和重新分配">重新声明和重新分配</h2>
<p>上面最后一个示例展示了简短声明的详细信息。调用<code>os.Open</code>的声明为:</p>
<pre><code class="language-go">f, err := os.Open(name)
</code></pre>
<p>该语句声明了两个变量<code>f</code>和<code>err</code>。几行后，对<code>f.Stat</code>的调用显示为:</p>
<pre><code class="language-go">d, err := f.Stat()
</code></pre>
<p>看起来好像声明了<code>d</code>和<code>err</code>。但是请注意，<code>err</code>出现在两个语句中。这种重复是合法的：<code>err</code>由第一个语句声明，但仅在第二个语句中重新分配。这意味着对<code>f.Stat</code>的调用将使用上面声明的现有<code>err</code>变量，并为其赋予一个新值。</p>
<p>在<code>:=</code>声明中，即使已经声明了变量<code>v</code>，也可能会出现它，条件是:</p>
<ul>
<li>此声明与v的现有声明在同一作用域内(如果v已在外部作用域中声明，则该声明将创建一个新变量)</li>
<li>并且初始化中的对应值可分配给v</li>
<li>声明创建了至少一个其他变量。</li>
</ul>
<p>这种不寻常的特性通常很实用，例如在<code>if-else</code>长链中，可以轻松的使用单个err值。</p>
<p>值得注意的是，在Go中，函数参数和返回值的范围与函数主体相同，即使它们按词法出现在包围主体的括号之外。</p>
<h2 id="for">for</h2>
<p>Go <code>for</code>循环类似于C，但不相同。它统一了<code>for</code>和<code>while</code>并且没有<code>do while</code>。共有三种形式，其中只有一种具有分号。</p>
<pre><code class="language-go">// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
</code></pre>
<p>简短声明使在循环中轻松声明索引变量变得容易。</p>
<pre><code class="language-go">sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</code></pre>
<p>如果要遍历<code>array</code>, <code>slice</code>, <code>string</code>或<code>map</code>，或从<code>channel</code>读取，则<code>range</code>可以管理该循环。</p>
<pre><code class="language-go">for key, value := range oldMap {
    newMap[key] = value
}
</code></pre>
<p>如果只需要<code>range(键或索引)</code>中的第一项，请删除第二项:</p>
<pre><code class="language-go">for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
</code></pre>
<p>如果只需要<code>range(值)</code>中的第二项，则使用<a href="https://golang.org/doc/effective_go.html#blank">空白标识符</a>(<code>下划线</code>)来丢弃第一项:</p>
<pre><code class="language-go">sum := 0
for _, value := range array {
    sum += value
}
</code></pre>
<p>对于字符串，<code>range</code>做了更多事情，通过解析UTF-8来分解单个Unicode代码点。错误的编码会占用一个字节并产生替换符U+FFFD(<code>rune</code>(具有关联的内置类型)是用于单个Unicode代码点的Go术语。有关详细信息，请参见<a href="https://golang.org/ref/spec#Rune_literals">语言规范</a>)</p>
<pre><code class="language-go">for pos, char := range &quot;日本\x80語&quot; { // \x80 is an illegal UTF-8 encoding
    fmt.Printf(&quot;character %#U starts at byte position %d\n&quot;, char, pos)
}
</code></pre>
<p>打印结果:</p>
<pre><code class="language-go">character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
</code></pre>
<p>最后，Go没有逗号运算符，而<code>++</code>和<code>--</code>是语句而不是表达式。如果想在<code>for</code>循环中使用多个变量你应该使用多个赋值语句(尽管这排除了++和--)。</p>
<pre><code class="language-go">// Reverse a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</code></pre>
<h2 id="switch">switch</h2>
<p>Go的switch语句比C的更通用。表达式不必是常量，甚至不必是整数，从上到下进行评估，直到找到匹配项为止；如果该switch没有表达式，则将其设置为true。因此，尽可能的将<code>if-else-if-else</code>链编写为<code>switch</code>。</p>
<pre><code class="language-go">func unhex(c byte) byte {
    switch {
    case '0' &lt;= c &amp;&amp; c &lt;= '9':
        return c - '0'
    case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
        return c - 'a' + 10
    case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
        return c - 'A' + 10
    }
    return 0
}
</code></pre>
<p>不会自动<code>full through</code>，但<code>case</code>可以用逗号分隔的列表显示。</p>
<pre><code class="language-go">func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&amp;', '=', '#', '+', '%':
        return true
    }
    return false
}
</code></pre>
<p>尽管它们在Go中不像其他一些类似C的语言那样普遍，但是break语句可用于尽早终止<code>switch</code>。但是，有时需要跳出周围的循环而不是switch，而在Go中，可以通过在循环上放置标签并&quot;breaking&quot;该标签来实现。下面示例显示了两种用法。</p>
<pre><code class="language-go">Loop:
	for n := 0; n &lt; len(src); n += size {
		switch {
		case src[n] &lt; sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] &lt; sizeTwo:
			if n+1 &gt;= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]&lt;&lt;shift)
		}
	}
</code></pre>
<p>当然，<code>continue</code>语句也接受可选标签，但仅适用于循环。<br>
下面是一个使用两个switch语句的字节切片比较例程:</p>
<pre><code class="language-go">// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &gt; len(b):
        return 1
    case len(a) &lt; len(b):
        return -1
    }
    return 0
}
</code></pre>
<h2 id="类型检查">类型检查</h2>
<p><code>switch</code>也可以用来检查接口变量的动态类型。这种类型switch使用类型断言声明的语法，并在括号内使用关键字<code>type</code>。如果switch在表达式中声明了变量，则该变量在每个子句中将具有相应的类型。在这种情况下重用名称也是惯用的，实际上是在每种情况下声明一个具有相同名称但类型不同的新变量。</p>
<pre><code class="language-go">var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf(&quot;unexpected type %T\n&quot;, t)     // %T prints whatever type t has
case bool:
    fmt.Printf(&quot;boolean %t\n&quot;, t)             // t has type bool
case int:
    fmt.Printf(&quot;integer %d\n&quot;, t)             // t has type int
case *bool:
    fmt.Printf(&quot;pointer to boolean %t\n&quot;, *t) // t has type *bool
case *int:
    fmt.Printf(&quot;pointer to integer %d\n&quot;, *t) // t has type *int
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2.1 - Go: 最佳实践(命名、分号)]]></title>
        <id>https://whimthen.github.io/post/MrgRqSA0X/</id>
        <link href="https://whimthen.github.io/post/MrgRqSA0X/">
        </link>
        <updated>2020-03-24T05:50:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="命名">命名</h1>
<p>命名在Go语言中与其他任何语言一样重要。它们甚至具有语义效果: 包外部名称的可见性取决于其首字符是否为大写。因此，值得花一些时间讨论Go程序中的命名约定。</p>
<h2 id="包名">包名</h2>
<p>当导入一个包后，包名称将成为内容的访问器。</p>
<pre><code class="language-go">import &quot;bytes&quot;
</code></pre>
<p>导入包后可以访问<code>bytes.Buffer</code>。如果每个使用该包的人都可以使用相同的名称来引用其内容，这将很有帮助，这意味着该软件包的名称应该很好: 简短，简洁，令人回味。按照惯例，包名使用小写的单字名称。不需要下划线或首字母大写。为了简便起见，Err是错误的，因为每个使用您的软件包的人都会输入该名称。而且不必担心冲突。包名称仅是导入的默认名称。它不必在所有源代码中都是唯一的，并且在发生冲突的极少数情况下，导入包可以选择其他名称以在本地使用。在任何情况下，混淆都是很少的，因为导入的文件名决定了所使用的软件包。</p>
<p>另一个约定是，程序包名称是其源目录的基本名称。<code>src/encoding/base64</code>中的包被导入为<code>&quot;encoding/base64&quot;</code>，但名称为base64，而不是<code>encoding_base64</code>，也不是<code>encodingBase64</code>。</p>
<p>程序包的导入者将使用该名称来引用其内容，因此，程序包中导出的名称可以使用该实例。(不要使用<code>import .</code>表示，可以简化必须在测试包之外运行的测试，但应避免使用。)例如，<code>bufio</code>包中<code>buffered reader</code>类型称为<code>Reader</code>，而不是<code>BufReader</code>，因为用户将其视为<code>bufio.Reader</code>，这是一个简洁明了的名称。此外，由于导入的实体始终使用其包名称来寻址，因此<code>bufio.Reader</code>不会与<code>io.Reader</code>冲突。类似地，用于创建<code>ring.Ring</code>新实例的函数（<code>Ring</code>是Go中构造函数的定义）通常被称为<code>NewRing</code>，但是由于<code>Ring</code>是软件包唯一导出的类型，并且由于该软件包被称为<code>ring</code>，因此称为<code>New</code>，该软件包的客户端将其称为<code>ring.New</code>。使用包结构可以帮助您选择好名字。</p>
<p>另一个简短的例子是<code>once.Do(setup)</code>工作的很好，并且不会因写成<code>DoOrWaitUntilDone(setup)</code>而得到改善。长命名不会自动使事情更具可读性。有用的文档注释通常比加长名称更有价值。</p>
<h2 id="getters">Getters</h2>
<p>Go不自动为getter和setter提供支持。自己提供getter和setter并没有错，这样做通常是适当的，但是将Get用作getter的名称既不是惯用的，也没有必要。如果您有一个名为<code>owner</code>(小写，未导出)的字段，则getter方法应称为<code>Owner</code>(大写，导出)，而不是<code>GetOwner</code>。使用大写名称进行导出可提供钩子，以将字段与方法区分开。如果需要的话，一个setter函数将被称为<code>SetOwner</code>。这两个名字在实践中都很好理解:</p>
<pre><code class="language-go">owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</code></pre>
<h2 id="接口名称">接口名称</h2>
<p>按照惯例，一种方法的接口使用方法名称加上<code>-er</code>后缀或类似的修饰名来构造代理名词：<code>Reader</code>，<code>Writer</code>，<code>Formatter</code>，<code>CloseNotifier</code>等。</p>
<p>有许多这样的名称，兑现它们和它们捕获的函数名称很有用。<code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>, <code>String</code>等具有规范的签名和含义。为避免混淆，除非您的方法具有相同的签名和含义，否则请不要给它们使用任何名称。相反，如果您的类型实现的方法的含义与熟知类型上的方法的含义相同，请为其赋予相同的名称和签名；调用您的字符串转换器方法<code>String</code>而不是<code>ToString</code>。</p>
<h2 id="mixedcaps">MixedCaps</h2>
<p>最后，Go中的约定是使用<code>MixedCaps</code>或<code>mixedCaps</code>而不是下划线来编写多字名称。</p>
<h1 id="分号">分号</h1>
<p>像C一样，Go的形式语法使用分号来终止语句，但是与C中不同，这些分号不会出现在源代码中。相反，词法分析器使用一条简单的规则在扫描时自动插入分号，因此输入文本几乎没有分号。</p>
<p>规则是这样。如果换行符前的最后一个标记是标识符(包括<code>int</code>和<code>float64</code>之类的单词)，基本文字(例如数字或字符串常量)或其中一个标记</p>
<pre><code class="language-go">break continue fallthrough return ++ -- ) }
</code></pre>
<p>词法分析器总是在标记后插入分号。可以概括为：“如果换行符位于可以结束语句的标记之后，请插入分号”。</p>
<p>也可以在右括号之前省略分号，因此可以使用如下语句:</p>
<pre><code class="language-go">go func() { for { dst &lt;- &lt;-src } }()
</code></pre>
<p>不需要分号。Go一般仅在诸如<code>for</code>循环子句之类的地方具有分号，以分隔初始化程序，条件和延续元素。如果以这种方式编写代码，则在一行上分隔多个语句也是必需的。</p>
<p>分号插入规则的一个后果是，您不能在下一行上放置控件结构的开头括号(<code>if</code>, <code>for</code>, <code>switch</code> or <code>select</code>)。如果这样做，将在分号之前插入一个分号，这可能会导致不想要的效果。像下面这样:</p>
<pre><code class="language-go">if i &lt; f() {
    g()
}
</code></pre>
<p>而并非这样:</p>
<pre><code class="language-go">if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2 - Go: 最佳实践(格式化、注释)]]></title>
        <id>https://whimthen.github.io/post/ts0GeTvyX/</id>
        <link href="https://whimthen.github.io/post/ts0GeTvyX/">
        </link>
        <updated>2020-03-24T04:06:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="引言">引言</h1>
<p>Go作为一门新的编程语言，借鉴了很多语言的想法。Go具有非同寻常的特性，使得在编程上和其他语言有所不同。将<code>C++</code>或<code>Java</code>程序直接转换为Go不太可能产生令人满意的结果-Java程序是用Java而不是Go编写的。另一方面，从Go角度考虑问题可能会成功但完全不同的程序。换句话说，要编写好语言，重要的是要了解它的特性和语法。了解Go变成中已建立的约定(如: 命名、格式、结构等)也很重要，这样编写的程序将易于其他程序员理解。</p>
<p>本章将说明编写清晰、常用的Go语法代码提示。展示了<a href="https://golang.org/ref/spec">语言规范</a>和<a href="https://whimthen.github.io/post/kTvbgt91b/">如何编写Go代码</a>，应该首先阅读这些内容。</p>
<h1 id="格式化">格式化</h1>
<p>格式问题是最有争议但后果最不严重的问题。通常我们可以适应不通的格式样式，但是如果不必这样做会更好，如果每个人都遵循相同的央视，则花费再央视上的时间会更少。问题是如何在没有冗长的说明性风格指南的情况下处理这种理想中的事情。</p>
<p>使用Go，我们可以采用一种不寻常的方法，让机器处理大多数格式化问题。<code>gofmt</code>程序(也可作为<code>go fmt</code>使用，它再程序包级别而不是源文件级别运行)读取Go程序文件，并以锁紧和垂直对齐的标准样式格式化源代码，并保留注释，在必要时重新格式化注释。</p>
<p>例如: 无需花时间对结构字段上的注释进行排列，<code>Gofmt</code>将做到这一点。</p>
<pre><code class="language-go">type T struct {
    name string // name of the object
    value int // its value
}
</code></pre>
<p><code>gofmt</code>使各列对齐后:</p>
<pre><code class="language-go">type T struct {
    name    string // name of the object
    value   int    // its value
}
</code></pre>
<p>标准库中的所有Go代码均已使用gofmt格式化。</p>
<p>一些简短的格式详细信息:</p>
<ul>
<li>缩进: 默认情况下<code>gofmt</code>使用制表符进行缩进，仅在必要时使用空格。</li>
<li>行长度: Go没有行长限制，如果感觉太长，可以将其包裹起来并用制表符缩进。</li>
<li>括号: Go需要的括号比C和Java的更少，控制语句(if, for, switch)的语法中没有括号。而且运算符优先级层次更短更清晰，因此<code>x&lt;&lt;8 + y&lt;&lt;16</code>表示空格意味什么，与其他语言不同。</li>
</ul>
<h1 id="注释">注释</h1>
<p>Go提供了C样式的<code>/* */</code>块注释和C++样式的<code>//</code>行注释。行注释很平常，块注释主要用于程序包注释，但在表达式中很有用，或者禁用大量代码。</p>
<p><code>godoc</code>可以处理Go源文件以提取有关软件包内容的文档。在顶级声明之前出现的注释(没有中间换行符)与声明一起被提取，以用作该项目的解释行文本。这些注释的性质和样式决定了godoc生成的文档的质量。</p>
<p>每个包都应该在<code>package</code>声明之前有一个包注释(块注释)。对于多个文件包，包注释仅需要出现在一个文件中，任何一个都可以。包注释应该介绍该包，并提供与该包有关的信息。它会出现在godoc页面上，应及时设置详细文档。</p>
<pre><code class="language-go">/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
</code></pre>
<p>如果包很简单，则包注释可以使用行注释:</p>
<pre><code class="language-go">// Package path implements utility routines for
// manipulating slash-separated filename paths.
package comment
</code></pre>
<p>注释不需要额外的格式，例如星号标识。生成的注释甚至不会以固定宽度的字体显示，因此不需要以来对齐间距。<code>godoc</code>(例如: <code>gofmt</code>)会处理这些问题。注释是未经解释的纯文本，因此HTML和其他注释（如<code>_this_</code>）将逐字复制，因此不应使用。godoc所做的一种调整是以固定宽度的字体显示缩进的文本，适用于程序片段。</p>
<p>根据上下文的不同，godoc可能甚至不会重新格式化注释，因此请确保它们看起来直截了当: 使用正确的拼写，标点和句子结构，折叠长行等。</p>
<p>在包中，顶级声明之前的任何注释都将用作该声明的文档注释。程序中的每个导出(大写)名称都应带有文档注释。</p>
<p>Doc注释最好作为完整的句子使用，它可以进行各种各样的自动演示。第一句应为单句摘要，以声明的名称开头。</p>
<pre><code class="language-go">// Compile parses a regular expression and returns, if successful,
// a Regexp that can be used to match against text.
func Compile(str string) (*Regexp, error) {
</code></pre>
<p>如果每个文档注释都以其描述的项目名称开头，则可以使用go工具的doc子命令并通过grep运行输出。想象一下，您忘记了名称&quot;Compile&quot;，但正在寻找正则表达式的解析函数，因此您运行了命令:</p>
<pre><code class="language-shell">$ go doc -all regexp | grep -i parse
</code></pre>
<p>如果包中的所有文档注释均以&quot;This function...&quot;开头，则grep不会帮助您记住该名称。但是，因为该软件包以每个文档注释的名称开头，所以您会看到类似这样的内容，会记住您要查找的单词。</p>
<pre><code class="language-shell">$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
$
</code></pre>
<p>Go的声明语法允许对声明进行分组。单个文档注释可以引入一组相关的常量或变量。由于整个声明都已表达，因此这样的注释常常是含糊的。</p>
<pre><code class="language-go">// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New(&quot;regexp: internal error&quot;)
    ErrUnmatchedLpar = errors.New(&quot;regexp: unmatched '('&quot;)
    ErrUnmatchedRpar = errors.New(&quot;regexp: unmatched ')'&quot;)
    ...
)
</code></pre>
<p>分组还可以指示项目之间的关系，例如一组变量受互斥锁保护的事实。</p>
<pre><code class="language-go">var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.1 - Go: 如何编写Go代码]]></title>
        <id>https://whimthen.github.io/post/kTvbgt91b/</id>
        <link href="https://whimthen.github.io/post/kTvbgt91b/">
        </link>
        <updated>2020-03-23T07:34:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>本文档演示了模块内部简单Go软件包的开发，并介绍了<a href="https://golang.org/cmd/go/">go工具</a>，这是获取，构建和安装Go模块，软件包和命令的标准方法。<br>
<strong>注意:</strong> 本文档使用的是Go 1.13或更高版本，并且未设置<code>GO111MODULE</code>环境变量。如果使用更低版本Go，请查看<a href="https://golang.org/doc/gopath_code.html">官方文档</a>。</p>
<h1 id="组织代码">组织代码</h1>
<p>Go程序用包来组织代码。包是在同一目录中一起编译的源文件的集合。在一个go源文件中定义的函数，类型，变量和常量对于同一包中的所有其他源文件可见。</p>
<p>存储库包含一个或多个模块。模块是一起发布的相关Go软件包的集合。Go存储库通常仅包含一个模块，该模块位于存储库的根目录。<code>go.mod</code>文件中声明了<code>模块路径</code>: 模块内所有软件包的倒入路径前缀。该模块将软件包包含在包含其<code>go.mod</code>文件的目录以及该目录的子目录中，直至包含另一个<code>go.mod</code>文件（如果有）的下一个子目录。</p>
<p>请注意，在构建代码之前，无需将代码发布到远程存储库。可以在本地定义模块，而不必属于存储库。但是，组织代码是一种好习惯，就像您有一天要发布代码一样。</p>
<p>每个模块的路径不仅充当其软件包的导入路径前缀，而且还指示go命令将其下载到的位置。例如，为了下载模块<code>golang.org/x/tools</code>，go命令将查询<code>https://golang.org/x/tools</code>所指示的存储库(<a href="https://golang.org/cmd/go/#hdr-Relative_import_paths">此处有更多说明</a>)。</p>
<p>导入路径是用于导入软件包的字符串。包的导入路径是其模块路径及其在模块中的子目录。例如: 模块<code>github.com/google/go-cmp</code>在目录<code>cmp/</code>中包含一个包。该包的倒入路径为<code>github.com/google/go-cmp/cmp</code>。标准库中的包没有模块路径前缀。</p>
<h1 id="第一个程序">第一个程序</h1>
<p>要编译并运行一个程序，首先选择一个模块路径(例如: <code>example.com/user/hello</code>)，然后创建一个声明它的<code>go.mod</code>文件。</p>
<pre><code class="language-shell">$ mkdir hello
$ cd hello
$ go mod init example.com/user/hello
go: creating new go.mod: module example.com/user/hello
$ cat go.mod
module example.com/user/hello

go 1.14
$
</code></pre>
<p>Go源文件中的第一条语句必须是程序包名称。可执行命令必须始终使用包<code>main</code>。<br>
接下来，在该目录中创建一个名为<code>hello.go</code>的文件，其中包含以下Go代码:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello, world.&quot;)
}
</code></pre>
<p>现在可以使用go工具编译并安装程序:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<p>该命令生成名为<code>hello</code>的可执行二进制文件。然后，将该二进制文件安装为<code>$HOME/go/bin/hello</code>(或在Windows下为<code>%USERPROFILE%\go\bin\hello.exe</code>)。</p>
<p>安装路径取决于<a href="">环境变量</a><code>GOPATH</code>和<code>GOBIN</code>。如果设置了<code>GOBIN</code>，则二进制文件被安装在此目录中。如果设置了<code>GOPATH</code>，二进制文件被安装到<code>GOPATH</code>列表中第一个目录的<code>bin</code>子目录中。除此以外，二进制文件被安装到默认的<code>GOPATH</code>(<code>$HOME/go</code>或<code>%USERPROFILE%\go</code>)的<code>bin</code>子目录中。</p>
<p>您可以使用<code>go env</code>命令为以后的go命令可移植地设置环境变量的默认值:</p>
<pre><code class="language-shell">$ go env -w GOBIN=/somewhere/else/bin
</code></pre>
<p>要取消设置先前由<code>go env -w</code>设置的变量，请使用<code>go env -u</code>:</p>
<pre><code class="language-shell">$ go env -u GOBIN
</code></pre>
<p>像<code>go install</code>之类的命令适用于包含当前工作目录的模块的上下文。如果工作目录不在<code>example.com/user/hello</code>模块内，则安装可能失败。</p>
<p>为了方便起见，go命令接受相对于工作目录的路径，如果没有其他路径，则默认使用当前工作目录中的软件包。<br>
因此，在我们的工作目录中，以下命令都是等效的:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<pre><code class="language-shell">$ go install .
</code></pre>
<pre><code class="language-shell">$ go install
</code></pre>
<p>接下来，运行程序以确保可以正常工作。为了方便程序的运行，通常将安装目录添加到环境变量<code>PATH</code>中，使运行二进制文件变的更加简单:</p>
<pre><code class="language-shell"># Windows用户应查阅 https://github.com/golang/go/wiki/SettingGOPATH
# 设置%PATH%变量.
$ export PATH=$PATH:$(dirname $(go list -f '{{.Target}}' .))
$ ./hello
Hello, world.
</code></pre>
<p>如果你是用版本管理系统，现在是初始化仓库的最好时机。添加并提交你的第一次修改。再一次说明: 这是不是必须的，完全可以使用本地模块。</p>
<pre><code class="language-shell">$ git init
Initialized empty Git repository in /home/user/hello/.git/
$ git add go.mod hello.go
$ git commit -m &quot;initial commit&quot;
[master (root-commit) 0b4507d] initial commit
 1 file changed, 7 insertion(+)
 create mode 100644 go.mod hello.go
</code></pre>
<p>go命令通过请求相应的HTTPS URL并读取HTML响应中嵌入的元数据来查找包含给定模块路径的存储库(请参阅<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths">go help importpath</a>)。许多托管服务已经为包含Go代码的存储库提供了该元数据，因此使您的模块可供其他人使用的最简单方法通常是使其模块路径与存储库的URL相匹配。</p>
<h1 id="在你的模块中导入包">在你的模块中导入包</h1>
<p>编写一个<code>morestrings</code>包，并在<code>hello</code>程序中使用它。首先创建一个名为<code>$HOME/hello/morestrings</code>的目录，然后在该目录中创建一个名为<code>reverse.go</code>的文件，包含以下内容:</p>
<pre><code class="language-go">// 包morestrings实现了其他功能来操纵UTF-8
// 编码的字符串，超出标准“字符串”包中提供的字符串。
package morestrings

// ReverseRunes 返回其参数字符串，从左向右以符文方向反转。
func ReverseRunes(s string) string {
	r := []rune(s)
	for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
	return string(r)
}
</code></pre>
<p>因为<code>ReverseRunes</code>以大些字符开头，它意味着是<a href="https://golang.org/ref/spec#Exported_identifiers">可导出</a>的。并可以在导入morestrings软件包的其他软件包中使用。</p>
<p>让我们测试一下该软件包可以通过<code>go build</code>编译:</p>
<pre><code class="language-shell">$ cd $HOME/hello/morestrings
$ go build
</code></pre>
<p>这不会产生输出文件。而是将已编译的程序包保存在本地构建缓存中。</p>
<p>确认<code>morestrings</code>包构建后，在<code>hello</code>中使用，修改原始的<code>$HOME/hello/hello.go</code>来使用:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;example.com/user/hello/morestrings&quot;
)

func main() {
	fmt.Println(morestrings.ReverseRunes(&quot;!oG ,olleH&quot;))
}
</code></pre>
<p>安装<code>hello</code>程序:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<p>运行新版本的程序，应该可以看到一条新的反向消息:</p>
<pre><code class="language-shell">$ hello
Hello, Go!
</code></pre>
<h1 id="从远程模块导入包">从远程模块导入包</h1>
<p>导入路径可以描述如何使用版本控制系统(如<code>Git</code>或<code>Mercurial</code>)获取软件包源代码。go工具使用此属性来自动从远程存储库获取软件包。例如，要在程序中使用<code>github.com/google/go-cmp/cmp</code>:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;example.com/user/hello/morestrings&quot;
	&quot;github.com/google/go-cmp/cmp&quot;
)

func main() {
	fmt.Println(morestrings.ReverseRunes(&quot;!oG ,olleH&quot;))
	fmt.Println(cmp.Diff(&quot;Hello World&quot;, &quot;Hello Go&quot;))
}
</code></pre>
<p>当您运行诸如<code>go install</code>，<code>go build</code>或<code>go run</code>之类的命令时，go命令将自动下载远程模块并将其版本记录在<code>go.mod</code>文件中:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
go: finding module for package github.com/google/go-cmp/cmp
go: downloading github.com/google/go-cmp v0.4.0
go: found github.com/google/go-cmp/cmp in github.com/google/go-cmp v0.4.0
$ hello
Hello, Go!
  string(
- 	&quot;Hello World&quot;,
+ 	&quot;Hello Go&quot;,
  )
$ cat go.mod
module example.com/user/hello

go 1.14

require github.com/google/go-cmp v0.4.0
</code></pre>
<p>模块依赖项将自动下载到<code>GOPATH</code>环境变量指示的目录的<code>pkg/mod</code>子目录中。给定版本的模块的下载内容在需要该版本的所有其他模块之间共享，因此go命令将这些文件和目录标记为只读。<br>
要删除所有下载的模块，可以传递<code>-modcache</code>标志进行清理:</p>
<pre><code class="language-shell">$ go clean -modcache
</code></pre>
<h1 id="测试">测试</h1>
<p>Go具有由<code>go test</code>命令和测试包组成的轻量级测试框架。</p>
<p>通过创建一个名称以<code>_test.go</code>结尾的文件来编写测试，该文件包含名为<code>TestXXX</code>且具有签名<code>func (t * testing.T)</code>的函数。测试框架运行每个这样的功能。如果该函数调用诸如<code>t.Error</code>或<code>t.Fail</code>之类的失败函数，则认为测试已失败。</p>
<p>创建<code>$HOME/hello/morestrings/reverse_test.go</code>文件，并将以下代码添加到其中:</p>
<pre><code class="language-go">package morestrings

import &quot;testing&quot;

func TestReverseRunes(t *testing.T) {
  	cases := []struct {
  		  in, want string
  	}{
    		{&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;},
    		{&quot;Hello, 世界&quot;, &quot;界世 ,olleH&quot;},
    		{&quot;&quot;, &quot;&quot;},
  	}
  	for _, c := range cases {
    		got := ReverseRunes(c.in)
    		if got != c.want {
    			  t.Errorf(&quot;ReverseRunes(%q) == %q, want %q&quot;, c.in, got, c.want)
    		}
  	}
}
</code></pre>
<p>然后使用<code>go test</code>运行测试:</p>
<pre><code class="language-shell">$ go test
PASS
ok  	example.com/user/morestrings 0.165s
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1 - Go: 安装]]></title>
        <id>https://whimthen.github.io/post/getting-started-1/</id>
        <link href="https://whimthen.github.io/post/getting-started-1/">
        </link>
        <updated>2020-03-23T03:22:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>下载和安装Go编译器，工具和库的说明</p>
</blockquote>
<h1 id="下载go发行版">下载Go发行版</h1>
<p><a href="https://golang.org/dl/">转到下载页面</a><br>
官方二进制发行版适用于FreeBSD(10-STABLE及更高版本)，Linux，macOS(10.10及更高版本)和Windows操作系统以及32位(386)和64位(amd64)x86处理器架构。<br>
如果二进制发行版不适用于您的操作系统和架构的组合，请尝试从<a href="https://golang.org/doc/install/source">源代码安装</a>或<a href="https://golang.org/doc/install/gccgo">安装gccgo</a>而不是gc。</p>
<h1 id="系统要求">系统要求</h1>
<p>Go二进制发行版可用于这些受支持的操作系统和系统架构。在继续操作之前，请确保您的系统满足这些要求。</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作系统</th>
<th style="text-align:center">系统架构</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FreeBSD 10.3或更高版本</td>
<td style="text-align:center">amd64, 386</td>
<td style="text-align:left">Debian GNU/kFreeBSD不支持</td>
</tr>
<tr>
<td style="text-align:left">Linux 2.6.23或更高版本(带有glibc)</td>
<td style="text-align:center">amd64, 386, arm, arm64, s390x, ppc64le</td>
<td style="text-align:left">CentOS/RHEL 5.x不支持。需要从源码安装或其他的libc。</td>
</tr>
<tr>
<td style="text-align:left">macOS 10.10或更高版本</td>
<td style="text-align:center">amd64</td>
<td style="text-align:left">使用Xcode<sup>2</sup>提供的clang或gcc<sup>1</sup>支持<code>cgo</code></td>
</tr>
<tr>
<td style="text-align:left">Windows 7, Server 2008R2或更高版本</td>
<td style="text-align:center">amd64, 386</td>
<td style="text-align:left">使用MinGW(386)或MinGW-W64(amd64)提供gcc<sup>1</sup>。不需要<code>cygwin</code>或<code>msys</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>1: 仅当计划使用<a href="https://golang.org/cmd/cgo">cgo</a>时，才需要C编译器。<br>
2: 只需要为Xcode安装命令行工具。如果已经安装了<a href="https://developer.apple.com/Xcode/">Xcode</a>4.3+，则可以从&quot;下载&quot;首选项面板的&quot;组件&quot;选项卡中进行安装。</p>
</blockquote>
<h1 id="安装go工具">安装Go工具</h1>
<p>如果要从旧版Go升级，则必须先删除现有版本。</p>
<h1 id="linux-macos和freebsd压缩包">Linux, macOS和FreeBSD压缩包</h1>
<p><a href="https://golang.org/dl/">下载存档文件</a>并解压到<code>/usr/local</code></p>
<pre><code class="language-shell">$ tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz
</code></pre>
<p>选择适合你自己的存档文件。例如：如果你要在Linux上为64位x86安装<code>Go1.2.1</code>版本。则存档文件的名称应该是<code>go1.2.1.linux-amd64.tar.gz</code></p>
<blockquote>
<p>通常，这些命令必须以root用户或通过sudo运行</p>
</blockquote>
<p>将<code>/usr/local/go/bin</code>添加到系统环境变量中。或执行以下命令添加到<code>/etc/profile</code>或<code>$HOME/.profile</code></p>
<pre><code class="language-shell">$ export PATH=$PATH:/usr/local/go/bin
</code></pre>
<p><strong>注意:</strong> 修改配置文件可能需要等到下次重启系统才会生效。要立即应用更改，只需要直接运行shell命令或使用如<code>source ~/.profile</code>之类的命令。</p>
<h1 id="macos包安装器">macOS包安装器</h1>
<p><a href="https://golang.org/dl/">下载包文件</a>，打开并根据提示安装Go工具，该软件包将安装Go发行版到<code>/usr/local/go</code></p>
<p>该软件包需要将<code>/usr/local/go/bin</code>目录添加到系统环境变量中，你可能需要重新启动所有打开的终端会话以使更改生效。</p>
<h1 id="windows">Windows</h1>
<p>Go为Windows用户提供两种安装方式</p>
<ul>
<li><a href="https://golang.org/doc/install/source">源码安装</a>: 一个<code>zip</code>压缩包，必须设置一些环境变量</li>
<li><code>MSI安装器</code>: 使用该方式安装将自动配置</li>
</ul>
<h3 id="msi安装器">MSI安装器</h3>
<p>打开<a href="https://golang.org/dl/">MSI文件</a>并根据提示安装Go工具。默认将Go发行版安装到<code>c:/Go</code><br>
该安装器将<code>c:/Go/bin</code>目录放在系统环境变量中，你可能需要重启所有打开的命令行终端，以使更改生效。</p>
<h3 id="zip压缩包">Zip压缩包</h3>
<p><a href="https://golang.org/dl/">下载压缩包文件</a>并解压到指定目录。(建议使用: <code>c:/Go</code>)<br>
添加<code>bin</code>子目录到系统环境变量中(如: <code>c:/Go/bin</code>)</p>
<h3 id="在windows下设置环境变量">在Windows下设置环境变量</h3>
<p>在Windows下，您可以通过“系统”控制面板的“高级”选项卡上的“环境变量”按钮设置环境变量。Windows的某些版本通过“系统”控制面板中的“高级系统设置”选项提供此控制面板</p>
<h1 id="测试安装">测试安装</h1>
<p>使用一个简单的程序检查Go是否安装正确<br>
创建一个以<code>hello.go</code>命名的文件</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Printf(&quot;hello, world\n&quot;)
}
</code></pre>
<p>然后使用Go工具编译</p>
<pre><code class="language-shell">$ go build hello.go
</code></pre>
<p>上面的命令将在源代码旁边的当前目录中构建一个名为hello的可执行文件。执行以查看结果。</p>
<pre><code class="language-shell">$ ./hello
hello, world
</code></pre>
<p>如果你能看到&quot;hello, world&quot;消息说明安装成功</p>
<h1 id="安装额外的go版本">安装额外的Go版本</h1>
<p>在同一台计算机上安装多个Go版本可能很有用，例如，以确保软件包的测试可以通过多个Go版本。一旦安装了一个Go版本，就可以如下安装另一个版本(例如1.10.7)</p>
<pre><code class="language-shell">$ go get golang.org/dl/go1.10.7
$ go1.10.7 download
</code></pre>
<p>新下载的版本可以像go一样使用:</p>
<pre><code class="language-shell">$ go1.10.7 version
go version go1.10.7 linux/amd64
</code></pre>
<p><a href="https://godoc.org/golang.org/dl#pkg-subdirectories">下载页面</a>上列出了通过此方法可用的所有Go版本。您可以通过查看其GOROOT来找到这些额外的Go版本的安装位置。例如<code>go1.10.7 env GOROOT</code>。要卸载下载的版本，只需删除其GOROOT目录和goX.Y.Z二进制文件</p>
<h1 id="卸载go">卸载Go</h1>
<p>要从系统中删除现有的Go安装，请删除go目录。<br>
在Linux，macOS和FreeBSD下通常为<code>/usr/local/go</code>，在Windows下通常为<code>c:/Go</code><br>
您还应该从PATH环境变量中删除Go bin目录。<br>
在Linux和FreeBSD下，您应该编辑<code>/etc/profile</code>或<code>$HOME/.profile</code>。<br>
如果您使用macOS软件包安装了Go，则应删除<code>/etc/paths.d/go</code>文件。<br>
Windows用户应阅读有关在Windows下设置环境变量的部分。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NIO 中需要注意⚠️的事项]]></title>
        <id>https://whimthen.github.io/post/nio_notice/</id>
        <link href="https://whimthen.github.io/post/nio_notice/">
        </link>
        <updated>2020-03-18T07:24:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="处理事件忘记移除key">处理事件忘记移除key</h1>
<p>在select返回值大于0的情况下，循环处理Selector.selectedKeys集合，每处理一个必须从Set中移除<br>
<font color="red">不移除的后果是本次的就绪的key集合下次会再次返回,导致无限循环，CPU消耗100%</font></p>
<pre><code class="language-java">Iterator&lt;SelectionKey&gt; it=set.iterator();
    While(it.hasNext()){
    SelectionKey key=it.next();
    it.remove(); //切记移除
    // 处理事件......
}
</code></pre>
<h1 id="selector-返回的-key-集合非线程安全">Selector 返回的 key 集合非线程安全</h1>
<ul>
<li>Selector.selectedKeys/keys 返回的集合都是非线程安全的</li>
<li>Selector.selectedKeys返回的可移除</li>
<li>Selector.keys 不可变</li>
<li>对selected keys的处理必须单线程处理或者适当同步</li>
</ul>
]]></content>
    </entry>
</feed>