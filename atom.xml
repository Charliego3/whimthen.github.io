<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://whimthen.github.io</id>
    <title>自留地</title>
    <updated>2020-03-24T04:07:06.589Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://whimthen.github.io"/>
    <link rel="self" href="https://whimthen.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://whimthen.github.io/images/avatar.png</logo>
    <icon>https://whimthen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 自留地</rights>
    <entry>
        <title type="html"><![CDATA[1.2 - Go: 最佳实践]]></title>
        <id>https://whimthen.github.io/post/ts0GeTvyX/</id>
        <link href="https://whimthen.github.io/post/ts0GeTvyX/">
        </link>
        <updated>2020-03-24T04:06:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="引言">引言</h1>
<p>Go作为一门新的编程语言，借鉴了很多语言的想法。Go具有非同寻常的特性，使得在编程上和其他语言有所不同。将<code>C++</code>或<code>Java</code>程序直接转换为Go不太可能产生令人满意的结果-Java程序是用Java而不是Go编写的。另一方面，从Go角度考虑问题可能会成功但完全不同的程序。换句话说，要编写好语言，重要的是要了解它的特性和语法。了解Go变成中已建立的约定(如: 命名、格式、结构等)也很重要，这样编写的程序将易于其他程序员理解。</p>
<p>本章将说明编写清晰、常用的Go语法代码提示。展示了<a href="https://golang.org/ref/spec">语言规范</a>和<a href="https://whimthen.github.io/post/kTvbgt91b/">如何编写Go代码</a>，应该首先阅读这些内容。</p>
<h1 id="格式化">格式化</h1>
<p>格式问题是最有争议但后果最不严重的问题。通常我们可以适应不通的格式样式，但是如果不必这样做会更好，如果每个人都遵循相同的央视，则花费再央视上的时间会更少。问题是如何在没有冗长的说明性风格指南的情况下处理这种理想中的事情。</p>
<p>使用Go，我们可以采用一种不寻常的方法，让机器处理大多数格式化问题。<code>gofmt</code>程序(也可作为<code>go fmt</code>使用，它再程序包级别而不是源文件级别运行)读取Go程序文件，并以锁紧和垂直对齐的标准样式格式化源代码，并保留注释，在必要时重新格式化注释。</p>
<p>例如: 无需花时间对结构字段上的注释进行排列，<code>Gofmt</code>将做到这一点。</p>
<pre><code class="language-go">type T struct {
    name string // name of the object
    value int // its value
}
</code></pre>
<p><code>gofmt</code>使各列对齐后:</p>
<pre><code class="language-go">type T struct {
    name    string // name of the object
    value   int    // its value
}
</code></pre>
<p>标准库中的所有Go代码均已使用gofmt格式化。</p>
<p>一些简短的格式详细信息:</p>
<ul>
<li>缩进: 默认情况下<code>gofmt</code>使用制表符进行缩进，仅在必要时使用空格。</li>
<li>行长度: Go没有行长限制，如果感觉太长，可以将其包裹起来并用制表符缩进。</li>
<li>括号: Go需要的括号比C和Java的更少，控制语句(if, for, switch)的语法中没有括号。而且运算符优先级层次更短更清晰，因此<code>x&lt;&lt;8 + y&lt;&lt;16</code>表示空格意味什么，与其他语言不同。</li>
</ul>
<h1 id="注释">注释</h1>
<p>Go提供了C样式的<code>/* */</code>块注释和C++样式的<code>//</code>行注释。行注释很平常，块注释主要用于程序包注释，但在表达式中很有用，或者禁用大量代码。</p>
<p><code>godoc</code>可以处理Go源文件以提取有关软件包内容的文档。在顶级声明之前出现的注释(没有中间换行符)与声明一起被提取，以用作该项目的解释行文本。这些注释的性质和样式决定了godoc生成的文档的质量。</p>
<p>每个包都应该在<code>package</code>声明之前有一个包注释(块注释)。对于多个文件包，包注释仅需要出现在一个文件中，任何一个都可以。包注释应该介绍该包，并提供与该包有关的信息。它会出现在godoc页面上，应及时设置详细文档。</p>
<pre><code class="language-go">/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
</code></pre>
<p>如果包很简单，则包注释可以使用行注释:</p>
<pre><code class="language-go">// Package path implements utility routines for
// manipulating slash-separated filename paths.
package comment
</code></pre>
<p>注释不需要额外的格式，例如星号标识。生成的注释甚至不会以固定宽度的字体显示，因此不需要以来对齐间距。<code>godoc</code>(例如: <code>gofmt</code>)会处理这些问题。注释是未经解释的纯文本，因此HTML和其他注释（如<code>_this_</code>）将逐字复制，因此不应使用。godoc所做的一种调整是以固定宽度的字体显示缩进的文本，适用于程序片段。</p>
<p>根据上下文的不同，godoc可能甚至不会重新格式化注释，因此请确保它们看起来直截了当: 使用正确的拼写，标点和句子结构，折叠长行等。</p>
<p>在包中，顶级声明之前的任何注释都将用作该声明的文档注释。程序中的每个导出(大写)名称都应带有文档注释。</p>
<p>Doc注释最好作为完整的句子使用，它可以进行各种各样的自动演示。第一句应为单句摘要，以声明的名称开头。</p>
<pre><code class="language-go">// Compile parses a regular expression and returns, if successful,
// a Regexp that can be used to match against text.
func Compile(str string) (*Regexp, error) {
</code></pre>
<p>如果每个文档注释都以其描述的项目名称开头，则可以使用go工具的doc子命令并通过grep运行输出。想象一下，您忘记了名称&quot;Compile&quot;，但正在寻找正则表达式的解析函数，因此您运行了命令:</p>
<pre><code class="language-shell">$ go doc -all regexp | grep -i parse
</code></pre>
<p>如果包中的所有文档注释均以&quot;This function...&quot;开头，则grep不会帮助您记住该名称。但是，因为该软件包以每个文档注释的名称开头，所以您会看到类似这样的内容，会记住您要查找的单词。</p>
<pre><code class="language-shell">$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
$
</code></pre>
<p>Go的声明语法允许对声明进行分组。单个文档注释可以引入一组相关的常量或变量。由于整个声明都已表达，因此这样的注释常常是含糊的。</p>
<pre><code class="language-go">// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New(&quot;regexp: internal error&quot;)
    ErrUnmatchedLpar = errors.New(&quot;regexp: unmatched '('&quot;)
    ErrUnmatchedRpar = errors.New(&quot;regexp: unmatched ')'&quot;)
    ...
)
</code></pre>
<p>分组还可以指示项目之间的关系，例如一组变量受互斥锁保护的事实。</p>
<pre><code class="language-go">var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.1 - Go: 如何编写Go代码]]></title>
        <id>https://whimthen.github.io/post/kTvbgt91b/</id>
        <link href="https://whimthen.github.io/post/kTvbgt91b/">
        </link>
        <updated>2020-03-23T07:34:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>本文档演示了模块内部简单Go软件包的开发，并介绍了<a href="https://golang.org/cmd/go/">go工具</a>，这是获取，构建和安装Go模块，软件包和命令的标准方法。<br>
<strong>注意:</strong> 本文档使用的是Go 1.13或更高版本，并且未设置<code>GO111MODULE</code>环境变量。如果使用更低版本Go，请查看<a href="https://golang.org/doc/gopath_code.html">官方文档</a>。</p>
<h1 id="组织代码">组织代码</h1>
<p>Go程序用包来组织代码。包是在同一目录中一起编译的源文件的集合。在一个go源文件中定义的函数，类型，变量和常量对于同一包中的所有其他源文件可见。</p>
<p>存储库包含一个或多个模块。模块是一起发布的相关Go软件包的集合。Go存储库通常仅包含一个模块，该模块位于存储库的根目录。<code>go.mod</code>文件中声明了<code>模块路径</code>: 模块内所有软件包的倒入路径前缀。该模块将软件包包含在包含其<code>go.mod</code>文件的目录以及该目录的子目录中，直至包含另一个<code>go.mod</code>文件（如果有）的下一个子目录。</p>
<p>请注意，在构建代码之前，无需将代码发布到远程存储库。可以在本地定义模块，而不必属于存储库。但是，组织代码是一种好习惯，就像您有一天要发布代码一样。</p>
<p>每个模块的路径不仅充当其软件包的导入路径前缀，而且还指示go命令将其下载到的位置。例如，为了下载模块<code>golang.org/x/tools</code>，go命令将查询<code>https://golang.org/x/tools</code>所指示的存储库(<a href="https://golang.org/cmd/go/#hdr-Relative_import_paths">此处有更多说明</a>)。</p>
<p>导入路径是用于导入软件包的字符串。包的导入路径是其模块路径及其在模块中的子目录。例如: 模块<code>github.com/google/go-cmp</code>在目录<code>cmp/</code>中包含一个包。该包的倒入路径为<code>github.com/google/go-cmp/cmp</code>。标准库中的包没有模块路径前缀。</p>
<h1 id="第一个程序">第一个程序</h1>
<p>要编译并运行一个程序，首先选择一个模块路径(例如: <code>example.com/user/hello</code>)，然后创建一个声明它的<code>go.mod</code>文件。</p>
<pre><code class="language-shell">$ mkdir hello
$ cd hello
$ go mod init example.com/user/hello
go: creating new go.mod: module example.com/user/hello
$ cat go.mod
module example.com/user/hello

go 1.14
$
</code></pre>
<p>Go源文件中的第一条语句必须是程序包名称。可执行命令必须始终使用包<code>main</code>。<br>
接下来，在该目录中创建一个名为<code>hello.go</code>的文件，其中包含以下Go代码:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello, world.&quot;)
}
</code></pre>
<p>现在可以使用go工具编译并安装程序:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<p>该命令生成名为<code>hello</code>的可执行二进制文件。然后，将该二进制文件安装为<code>$HOME/go/bin/hello</code>(或在Windows下为<code>%USERPROFILE%\go\bin\hello.exe</code>)。</p>
<p>安装路径取决于<a href="">环境变量</a><code>GOPATH</code>和<code>GOBIN</code>。如果设置了<code>GOBIN</code>，则二进制文件被安装在此目录中。如果设置了<code>GOPATH</code>，二进制文件被安装到<code>GOPATH</code>列表中第一个目录的<code>bin</code>子目录中。除此以外，二进制文件被安装到默认的<code>GOPATH</code>(<code>$HOME/go</code>或<code>%USERPROFILE%\go</code>)的<code>bin</code>子目录中。</p>
<p>您可以使用<code>go env</code>命令为以后的go命令可移植地设置环境变量的默认值:</p>
<pre><code class="language-shell">$ go env -w GOBIN=/somewhere/else/bin
</code></pre>
<p>要取消设置先前由<code>go env -w</code>设置的变量，请使用<code>go env -u</code>:</p>
<pre><code class="language-shell">$ go env -u GOBIN
</code></pre>
<p>像<code>go install</code>之类的命令适用于包含当前工作目录的模块的上下文。如果工作目录不在<code>example.com/user/hello</code>模块内，则安装可能失败。</p>
<p>为了方便起见，go命令接受相对于工作目录的路径，如果没有其他路径，则默认使用当前工作目录中的软件包。<br>
因此，在我们的工作目录中，以下命令都是等效的:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<pre><code class="language-shell">$ go install .
</code></pre>
<pre><code class="language-shell">$ go install
</code></pre>
<p>接下来，运行程序以确保可以正常工作。为了方便程序的运行，通常将安装目录添加到环境变量<code>PATH</code>中，使运行二进制文件变的更加简单:</p>
<pre><code class="language-shell"># Windows用户应查阅 https://github.com/golang/go/wiki/SettingGOPATH
# 设置%PATH%变量.
$ export PATH=$PATH:$(dirname $(go list -f '{{.Target}}' .))
$ ./hello
Hello, world.
</code></pre>
<p>如果你是用版本管理系统，现在是初始化仓库的最好时机。添加并提交你的第一次修改。再一次说明: 这是不是必须的，完全可以使用本地模块。</p>
<pre><code class="language-shell">$ git init
Initialized empty Git repository in /home/user/hello/.git/
$ git add go.mod hello.go
$ git commit -m &quot;initial commit&quot;
[master (root-commit) 0b4507d] initial commit
 1 file changed, 7 insertion(+)
 create mode 100644 go.mod hello.go
</code></pre>
<p>go命令通过请求相应的HTTPS URL并读取HTML响应中嵌入的元数据来查找包含给定模块路径的存储库(请参阅<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths">go help importpath</a>)。许多托管服务已经为包含Go代码的存储库提供了该元数据，因此使您的模块可供其他人使用的最简单方法通常是使其模块路径与存储库的URL相匹配。</p>
<h1 id="在你的模块中导入包">在你的模块中导入包</h1>
<p>编写一个<code>morestrings</code>包，并在<code>hello</code>程序中使用它。首先创建一个名为<code>$HOME/hello/morestrings</code>的目录，然后在该目录中创建一个名为<code>reverse.go</code>的文件，包含以下内容:</p>
<pre><code class="language-go">// 包morestrings实现了其他功能来操纵UTF-8
// 编码的字符串，超出标准“字符串”包中提供的字符串。
package morestrings

// ReverseRunes 返回其参数字符串，从左向右以符文方向反转。
func ReverseRunes(s string) string {
	r := []rune(s)
	for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
	return string(r)
}
</code></pre>
<p>因为<code>ReverseRunes</code>以大些字符开头，它意味着是<a href="https://golang.org/ref/spec#Exported_identifiers">可导出</a>的。并可以在导入morestrings软件包的其他软件包中使用。</p>
<p>让我们测试一下该软件包可以通过<code>go build</code>编译:</p>
<pre><code class="language-shell">$ cd $HOME/hello/morestrings
$ go build
</code></pre>
<p>这不会产生输出文件。而是将已编译的程序包保存在本地构建缓存中。</p>
<p>确认<code>morestrings</code>包构建后，在<code>hello</code>中使用，修改原始的<code>$HOME/hello/hello.go</code>来使用:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;example.com/user/hello/morestrings&quot;
)

func main() {
	fmt.Println(morestrings.ReverseRunes(&quot;!oG ,olleH&quot;))
}
</code></pre>
<p>安装<code>hello</code>程序:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<p>运行新版本的程序，应该可以看到一条新的反向消息:</p>
<pre><code class="language-shell">$ hello
Hello, Go!
</code></pre>
<h1 id="从远程模块导入包">从远程模块导入包</h1>
<p>导入路径可以描述如何使用版本控制系统(如<code>Git</code>或<code>Mercurial</code>)获取软件包源代码。go工具使用此属性来自动从远程存储库获取软件包。例如，要在程序中使用<code>github.com/google/go-cmp/cmp</code>:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;example.com/user/hello/morestrings&quot;
	&quot;github.com/google/go-cmp/cmp&quot;
)

func main() {
	fmt.Println(morestrings.ReverseRunes(&quot;!oG ,olleH&quot;))
	fmt.Println(cmp.Diff(&quot;Hello World&quot;, &quot;Hello Go&quot;))
}
</code></pre>
<p>当您运行诸如<code>go install</code>，<code>go build</code>或<code>go run</code>之类的命令时，go命令将自动下载远程模块并将其版本记录在<code>go.mod</code>文件中:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
go: finding module for package github.com/google/go-cmp/cmp
go: downloading github.com/google/go-cmp v0.4.0
go: found github.com/google/go-cmp/cmp in github.com/google/go-cmp v0.4.0
$ hello
Hello, Go!
  string(
- 	&quot;Hello World&quot;,
+ 	&quot;Hello Go&quot;,
  )
$ cat go.mod
module example.com/user/hello

go 1.14

require github.com/google/go-cmp v0.4.0
</code></pre>
<p>模块依赖项将自动下载到<code>GOPATH</code>环境变量指示的目录的<code>pkg/mod</code>子目录中。给定版本的模块的下载内容在需要该版本的所有其他模块之间共享，因此go命令将这些文件和目录标记为只读。<br>
要删除所有下载的模块，可以传递<code>-modcache</code>标志进行清理:</p>
<pre><code class="language-shell">$ go clean -modcache
</code></pre>
<h1 id="测试">测试</h1>
<p>Go具有由<code>go test</code>命令和测试包组成的轻量级测试框架。</p>
<p>通过创建一个名称以<code>_test.go</code>结尾的文件来编写测试，该文件包含名为<code>TestXXX</code>且具有签名<code>func (t * testing.T)</code>的函数。测试框架运行每个这样的功能。如果该函数调用诸如<code>t.Error</code>或<code>t.Fail</code>之类的失败函数，则认为测试已失败。</p>
<p>创建<code>$HOME/hello/morestrings/reverse_test.go</code>文件，并将以下代码添加到其中:</p>
<pre><code class="language-go">package morestrings

import &quot;testing&quot;

func TestReverseRunes(t *testing.T) {
  	cases := []struct {
  		  in, want string
  	}{
    		{&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;},
    		{&quot;Hello, 世界&quot;, &quot;界世 ,olleH&quot;},
    		{&quot;&quot;, &quot;&quot;},
  	}
  	for _, c := range cases {
    		got := ReverseRunes(c.in)
    		if got != c.want {
    			  t.Errorf(&quot;ReverseRunes(%q) == %q, want %q&quot;, c.in, got, c.want)
    		}
  	}
}
</code></pre>
<p>然后使用<code>go test</code>运行测试:</p>
<pre><code class="language-shell">$ go test
PASS
ok  	example.com/user/morestrings 0.165s
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1 - Go: 安装]]></title>
        <id>https://whimthen.github.io/post/getting-started-1/</id>
        <link href="https://whimthen.github.io/post/getting-started-1/">
        </link>
        <updated>2020-03-23T03:22:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>下载和安装Go编译器，工具和库的说明</p>
</blockquote>
<h1 id="下载go发行版">下载Go发行版</h1>
<p><a href="https://golang.org/dl/">转到下载页面</a><br>
官方二进制发行版适用于FreeBSD(10-STABLE及更高版本)，Linux，macOS(10.10及更高版本)和Windows操作系统以及32位(386)和64位(amd64)x86处理器架构。<br>
如果二进制发行版不适用于您的操作系统和架构的组合，请尝试从<a href="https://golang.org/doc/install/source">源代码安装</a>或<a href="https://golang.org/doc/install/gccgo">安装gccgo</a>而不是gc。</p>
<h1 id="系统要求">系统要求</h1>
<p>Go二进制发行版可用于这些受支持的操作系统和系统架构。在继续操作之前，请确保您的系统满足这些要求。</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作系统</th>
<th style="text-align:center">系统架构</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FreeBSD 10.3或更高版本</td>
<td style="text-align:center">amd64, 386</td>
<td style="text-align:left">Debian GNU/kFreeBSD不支持</td>
</tr>
<tr>
<td style="text-align:left">Linux 2.6.23或更高版本(带有glibc)</td>
<td style="text-align:center">amd64, 386, arm, arm64, s390x, ppc64le</td>
<td style="text-align:left">CentOS/RHEL 5.x不支持。需要从源码安装或其他的libc。</td>
</tr>
<tr>
<td style="text-align:left">macOS 10.10或更高版本</td>
<td style="text-align:center">amd64</td>
<td style="text-align:left">使用Xcode<sup>2</sup>提供的clang或gcc<sup>1</sup>支持<code>cgo</code></td>
</tr>
<tr>
<td style="text-align:left">Windows 7, Server 2008R2或更高版本</td>
<td style="text-align:center">amd64, 386</td>
<td style="text-align:left">使用MinGW(386)或MinGW-W64(amd64)提供gcc<sup>1</sup>。不需要<code>cygwin</code>或<code>msys</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>1: 仅当计划使用<a href="https://golang.org/cmd/cgo">cgo</a>时，才需要C编译器。<br>
2: 只需要为Xcode安装命令行工具。如果已经安装了<a href="https://developer.apple.com/Xcode/">Xcode</a>4.3+，则可以从&quot;下载&quot;首选项面板的&quot;组件&quot;选项卡中进行安装。</p>
</blockquote>
<h1 id="安装go工具">安装Go工具</h1>
<p>如果要从旧版Go升级，则必须先删除现有版本。</p>
<h1 id="linux-macos和freebsd压缩包">Linux, macOS和FreeBSD压缩包</h1>
<p><a href="https://golang.org/dl/">下载存档文件</a>并解压到<code>/usr/local</code></p>
<pre><code class="language-shell">$ tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz
</code></pre>
<p>选择适合你自己的存档文件。例如：如果你要在Linux上为64位x86安装<code>Go1.2.1</code>版本。则存档文件的名称应该是<code>go1.2.1.linux-amd64.tar.gz</code></p>
<blockquote>
<p>通常，这些命令必须以root用户或通过sudo运行</p>
</blockquote>
<p>将<code>/usr/local/go/bin</code>添加到系统环境变量中。或执行以下命令添加到<code>/etc/profile</code>或<code>$HOME/.profile</code></p>
<pre><code class="language-shell">$ export PATH=$PATH:/usr/local/go/bin
</code></pre>
<p><strong>注意:</strong> 修改配置文件可能需要等到下次重启系统才会生效。要立即应用更改，只需要直接运行shell命令或使用如<code>source ~/.profile</code>之类的命令。</p>
<h1 id="macos包安装器">macOS包安装器</h1>
<p><a href="https://golang.org/dl/">下载包文件</a>，打开并根据提示安装Go工具，该软件包将安装Go发行版到<code>/usr/local/go</code></p>
<p>该软件包需要将<code>/usr/local/go/bin</code>目录添加到系统环境变量中，你可能需要重新启动所有打开的终端会话以使更改生效。</p>
<h1 id="windows">Windows</h1>
<p>Go为Windows用户提供两种安装方式</p>
<ul>
<li><a href="https://golang.org/doc/install/source">源码安装</a>: 一个<code>zip</code>压缩包，必须设置一些环境变量</li>
<li><code>MSI安装器</code>: 使用该方式安装将自动配置</li>
</ul>
<h3 id="msi安装器">MSI安装器</h3>
<p>打开<a href="https://golang.org/dl/">MSI文件</a>并根据提示安装Go工具。默认将Go发行版安装到<code>c:/Go</code><br>
该安装器将<code>c:/Go/bin</code>目录放在系统环境变量中，你可能需要重启所有打开的命令行终端，以使更改生效。</p>
<h3 id="zip压缩包">Zip压缩包</h3>
<p><a href="https://golang.org/dl/">下载压缩包文件</a>并解压到指定目录。(建议使用: <code>c:/Go</code>)<br>
添加<code>bin</code>子目录到系统环境变量中(如: <code>c:/Go/bin</code>)</p>
<h3 id="在windows下设置环境变量">在Windows下设置环境变量</h3>
<p>在Windows下，您可以通过“系统”控制面板的“高级”选项卡上的“环境变量”按钮设置环境变量。Windows的某些版本通过“系统”控制面板中的“高级系统设置”选项提供此控制面板</p>
<h1 id="测试安装">测试安装</h1>
<p>使用一个简单的程序检查Go是否安装正确<br>
创建一个以<code>hello.go</code>命名的文件</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Printf(&quot;hello, world\n&quot;)
}
</code></pre>
<p>然后使用Go工具编译</p>
<pre><code class="language-shell">$ go build hello.go
</code></pre>
<p>上面的命令将在源代码旁边的当前目录中构建一个名为hello的可执行文件。执行以查看结果。</p>
<pre><code class="language-shell">$ ./hello
hello, world
</code></pre>
<p>如果你能看到&quot;hello, world&quot;消息说明安装成功</p>
<h1 id="安装额外的go版本">安装额外的Go版本</h1>
<p>在同一台计算机上安装多个Go版本可能很有用，例如，以确保软件包的测试可以通过多个Go版本。一旦安装了一个Go版本，就可以如下安装另一个版本(例如1.10.7)</p>
<pre><code class="language-shell">$ go get golang.org/dl/go1.10.7
$ go1.10.7 download
</code></pre>
<p>新下载的版本可以像go一样使用:</p>
<pre><code class="language-shell">$ go1.10.7 version
go version go1.10.7 linux/amd64
</code></pre>
<p><a href="https://godoc.org/golang.org/dl#pkg-subdirectories">下载页面</a>上列出了通过此方法可用的所有Go版本。您可以通过查看其GOROOT来找到这些额外的Go版本的安装位置。例如<code>go1.10.7 env GOROOT</code>。要卸载下载的版本，只需删除其GOROOT目录和goX.Y.Z二进制文件</p>
<h1 id="卸载go">卸载Go</h1>
<p>要从系统中删除现有的Go安装，请删除go目录。<br>
在Linux，macOS和FreeBSD下通常为<code>/usr/local/go</code>，在Windows下通常为<code>c:/Go</code><br>
您还应该从PATH环境变量中删除Go bin目录。<br>
在Linux和FreeBSD下，您应该编辑<code>/etc/profile</code>或<code>$HOME/.profile</code>。<br>
如果您使用macOS软件包安装了Go，则应删除<code>/etc/paths.d/go</code>文件。<br>
Windows用户应阅读有关在Windows下设置环境变量的部分。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NIO 中需要注意⚠️的事项]]></title>
        <id>https://whimthen.github.io/post/nio_notice/</id>
        <link href="https://whimthen.github.io/post/nio_notice/">
        </link>
        <updated>2020-03-18T07:24:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="处理事件忘记移除key">处理事件忘记移除key</h1>
<p>在select返回值大于0的情况下，循环处理Selector.selectedKeys集合，每处理一个必须从Set中移除<br>
<font color="red">不移除的后果是本次的就绪的key集合下次会再次返回,导致无限循环，CPU消耗100%</font></p>
<pre><code class="language-java">Iterator&lt;SelectionKey&gt; it=set.iterator();
    While(it.hasNext()){
    SelectionKey key=it.next();
    it.remove(); //切记移除
    // 处理事件......
}
</code></pre>
<h1 id="selector-返回的-key-集合非线程安全">Selector 返回的 key 集合非线程安全</h1>
<ul>
<li>Selector.selectedKeys/keys 返回的集合都是非线程安全的</li>
<li>Selector.selectedKeys返回的可移除</li>
<li>Selector.keys 不可变</li>
<li>对selected keys的处理必须单线程处理或者适当同步</li>
</ul>
]]></content>
    </entry>
</feed>