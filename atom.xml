<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://whimthen.github.io</id>
    <title>自留地</title>
    <updated>2020-03-25T03:45:21.222Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://whimthen.github.io"/>
    <link rel="self" href="https://whimthen.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://whimthen.github.io/images/avatar.png</logo>
    <icon>https://whimthen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 自留地</rights>
    <entry>
        <title type="html"><![CDATA[1.2.2 - Go: 最佳实践(流程控制结构)]]></title>
        <id>https://whimthen.github.io/post/pVvli46oS/</id>
        <link href="https://whimthen.github.io/post/pVvli46oS/">
        </link>
        <updated>2020-03-25T03:40:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Go的流程控制结构与C相关，但在重要方面有所不同。没有<code>do while</code>和<code>while</code>循环，只有<code>for</code>。<code>switch</code>很灵活。<code>if</code>和<code>switch</code>接受可选的初始化语句，像<code>for</code>一样。<code>break</code>和<code>continue</code>语句带有一个可选标签来标识要中断或继续的内容。包括了类型选择和多路复用选择器<code>select</code>。语法也略有不同：没有括号，并且主体必须始终用大括号分隔。</p>
</blockquote>
<h2 id="if">if</h2>
<p>在Go中，一个简单的if看起来像这样:</p>
<pre><code class="language-go">if x &gt; 0 {
    return y
}
</code></pre>
<p>在编写多行的<code>if</code>语句时必须使用括号。无论如何这样做都是好的风格，尤其是当主体包含控制语句(例如<code>return</code>或<code>break</code>)时。</p>
<p>由于<code>if</code>和<code>switch</code>接受初始化语句，因此通常会看到用来设置局部变量的语句。</p>
<pre><code class="language-go">if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</code></pre>
<p>在Go库中，当if语句不进入下一条语句时(即主体以<code>break</code>，<code>continue</code>，<code>goto</code>或<code>return</code>结尾)时，将省略不必要的<code>else</code>。</p>
<pre><code class="language-go">f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
</code></pre>
<p>这是一种常见情况的示例，在这种情况下，代码必须防止出现一系列错误情况。如果不进入if代码块，将向下继续执行，从而消除了出现错误的情况。由于错误一般以return语句结束，因此代码中不需要else语句。</p>
<pre><code class="language-go">f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
</code></pre>
<h2 id="重新声明和重新分配">重新声明和重新分配</h2>
<p>上面最后一个示例展示了简短声明的详细信息。调用<code>os.Open</code>的声明为:</p>
<pre><code class="language-go">f, err := os.Open(name)
</code></pre>
<p>该语句声明了两个变量<code>f</code>和<code>err</code>。几行后，对<code>f.Stat</code>的调用显示为:</p>
<pre><code class="language-go">d, err := f.Stat()
</code></pre>
<p>看起来好像声明了<code>d</code>和<code>err</code>。但是请注意，<code>err</code>出现在两个语句中。这种重复是合法的：<code>err</code>由第一个语句声明，但仅在第二个语句中重新分配。这意味着对<code>f.Stat</code>的调用将使用上面声明的现有<code>err</code>变量，并为其赋予一个新值。</p>
<p>在<code>:=</code>声明中，即使已经声明了变量<code>v</code>，也可能会出现它，条件是:</p>
<ul>
<li>此声明与v的现有声明在同一作用域内(如果v已在外部作用域中声明，则该声明将创建一个新变量)</li>
<li>并且初始化中的对应值可分配给v</li>
<li>声明创建了至少一个其他变量。</li>
</ul>
<p>这种不寻常的特性通常很实用，例如在<code>if-else</code>长链中，可以轻松的使用单个err值。</p>
<p>值得注意的是，在Go中，函数参数和返回值的范围与函数主体相同，即使它们按词法出现在包围主体的括号之外。</p>
<h2 id="for">for</h2>
<p>Go <code>for</code>循环类似于C，但不相同。它统一了<code>for</code>和<code>while</code>并且没有<code>do while</code>。共有三种形式，其中只有一种具有分号。</p>
<pre><code class="language-go">// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
</code></pre>
<p>简短声明使在循环中轻松声明索引变量变得容易。</p>
<pre><code class="language-go">sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</code></pre>
<p>如果要遍历<code>array</code>, <code>slice</code>, <code>string</code>或<code>map</code>，或从<code>channel</code>读取，则<code>range</code>可以管理该循环。</p>
<pre><code class="language-go">for key, value := range oldMap {
    newMap[key] = value
}
</code></pre>
<p>如果只需要<code>range(键或索引)</code>中的第一项，请删除第二项:</p>
<pre><code class="language-go">for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
</code></pre>
<p>如果只需要<code>range(值)</code>中的第二项，则使用<a href="https://golang.org/doc/effective_go.html#blank">空白标识符</a>(<code>下划线</code>)来丢弃第一项:</p>
<pre><code class="language-go">sum := 0
for _, value := range array {
    sum += value
}
</code></pre>
<p>对于字符串，<code>range</code>做了更多事情，通过解析UTF-8来分解单个Unicode代码点。错误的编码会占用一个字节并产生替换符U+FFFD(<code>rune</code>(具有关联的内置类型)是用于单个Unicode代码点的Go术语。有关详细信息，请参见<a href="https://golang.org/ref/spec#Rune_literals">语言规范</a>)</p>
<pre><code class="language-go">for pos, char := range &quot;日本\x80語&quot; { // \x80 is an illegal UTF-8 encoding
    fmt.Printf(&quot;character %#U starts at byte position %d\n&quot;, char, pos)
}
</code></pre>
<p>打印结果:</p>
<pre><code class="language-go">character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
</code></pre>
<p>最后，Go没有逗号运算符，而<code>++</code>和<code>--</code>是语句而不是表达式。如果想在<code>for</code>循环中使用多个变量你应该使用多个赋值语句(尽管这排除了++和--)。</p>
<pre><code class="language-go">// Reverse a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</code></pre>
<h2 id="switch">switch</h2>
<p>Go的switch语句比C的更通用。表达式不必是常量，甚至不必是整数，从上到下进行评估，直到找到匹配项为止；如果该switch没有表达式，则将其设置为true。因此，尽可能的将<code>if-else-if-else</code>链编写为<code>switch</code>。</p>
<pre><code class="language-go">func unhex(c byte) byte {
    switch {
    case '0' &lt;= c &amp;&amp; c &lt;= '9':
        return c - '0'
    case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
        return c - 'a' + 10
    case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
        return c - 'A' + 10
    }
    return 0
}
</code></pre>
<p>不会自动<code>full through</code>，但<code>case</code>可以用逗号分隔的列表显示。</p>
<pre><code class="language-go">func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&amp;', '=', '#', '+', '%':
        return true
    }
    return false
}
</code></pre>
<p>尽管它们在Go中不像其他一些类似C的语言那样普遍，但是break语句可用于尽早终止<code>switch</code>。但是，有时需要跳出周围的循环而不是switch，而在Go中，可以通过在循环上放置标签并&quot;breaking&quot;该标签来实现。下面示例显示了两种用法。</p>
<pre><code class="language-go">Loop:
	for n := 0; n &lt; len(src); n += size {
		switch {
		case src[n] &lt; sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] &lt; sizeTwo:
			if n+1 &gt;= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]&lt;&lt;shift)
		}
	}
</code></pre>
<p>当然，<code>continue</code>语句也接受可选标签，但仅适用于循环。<br>
下面是一个使用两个switch语句的字节切片比较例程:</p>
<pre><code class="language-go">// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &gt; len(b):
        return 1
    case len(a) &lt; len(b):
        return -1
    }
    return 0
}
</code></pre>
<h2 id="类型检查">类型检查</h2>
<p><code>switch</code>也可以用来检查接口变量的动态类型。这种类型switch使用类型断言声明的语法，并在括号内使用关键字<code>type</code>。如果switch在表达式中声明了变量，则该变量在每个子句中将具有相应的类型。在这种情况下重用名称也是惯用的，实际上是在每种情况下声明一个具有相同名称但类型不同的新变量。</p>
<pre><code class="language-go">var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf(&quot;unexpected type %T\n&quot;, t)     // %T prints whatever type t has
case bool:
    fmt.Printf(&quot;boolean %t\n&quot;, t)             // t has type bool
case int:
    fmt.Printf(&quot;integer %d\n&quot;, t)             // t has type int
case *bool:
    fmt.Printf(&quot;pointer to boolean %t\n&quot;, *t) // t has type *bool
case *int:
    fmt.Printf(&quot;pointer to integer %d\n&quot;, *t) // t has type *int
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2.1 - Go: 最佳实践(命名、分号)]]></title>
        <id>https://whimthen.github.io/post/MrgRqSA0X/</id>
        <link href="https://whimthen.github.io/post/MrgRqSA0X/">
        </link>
        <updated>2020-03-24T05:50:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="命名">命名</h1>
<p>命名在Go语言中与其他任何语言一样重要。它们甚至具有语义效果: 包外部名称的可见性取决于其首字符是否为大写。因此，值得花一些时间讨论Go程序中的命名约定。</p>
<h2 id="包名">包名</h2>
<p>当导入一个包后，包名称将成为内容的访问器。</p>
<pre><code class="language-go">import &quot;bytes&quot;
</code></pre>
<p>导入包后可以访问<code>bytes.Buffer</code>。如果每个使用该包的人都可以使用相同的名称来引用其内容，这将很有帮助，这意味着该软件包的名称应该很好: 简短，简洁，令人回味。按照惯例，包名使用小写的单字名称。不需要下划线或首字母大写。为了简便起见，Err是错误的，因为每个使用您的软件包的人都会输入该名称。而且不必担心冲突。包名称仅是导入的默认名称。它不必在所有源代码中都是唯一的，并且在发生冲突的极少数情况下，导入包可以选择其他名称以在本地使用。在任何情况下，混淆都是很少的，因为导入的文件名决定了所使用的软件包。</p>
<p>另一个约定是，程序包名称是其源目录的基本名称。<code>src/encoding/base64</code>中的包被导入为<code>&quot;encoding/base64&quot;</code>，但名称为base64，而不是<code>encoding_base64</code>，也不是<code>encodingBase64</code>。</p>
<p>程序包的导入者将使用该名称来引用其内容，因此，程序包中导出的名称可以使用该实例。(不要使用<code>import .</code>表示，可以简化必须在测试包之外运行的测试，但应避免使用。)例如，<code>bufio</code>包中<code>buffered reader</code>类型称为<code>Reader</code>，而不是<code>BufReader</code>，因为用户将其视为<code>bufio.Reader</code>，这是一个简洁明了的名称。此外，由于导入的实体始终使用其包名称来寻址，因此<code>bufio.Reader</code>不会与<code>io.Reader</code>冲突。类似地，用于创建<code>ring.Ring</code>新实例的函数（<code>Ring</code>是Go中构造函数的定义）通常被称为<code>NewRing</code>，但是由于<code>Ring</code>是软件包唯一导出的类型，并且由于该软件包被称为<code>ring</code>，因此称为<code>New</code>，该软件包的客户端将其称为<code>ring.New</code>。使用包结构可以帮助您选择好名字。</p>
<p>另一个简短的例子是<code>once.Do(setup)</code>工作的很好，并且不会因写成<code>DoOrWaitUntilDone(setup)</code>而得到改善。长命名不会自动使事情更具可读性。有用的文档注释通常比加长名称更有价值。</p>
<h2 id="getters">Getters</h2>
<p>Go不自动为getter和setter提供支持。自己提供getter和setter并没有错，这样做通常是适当的，但是将Get用作getter的名称既不是惯用的，也没有必要。如果您有一个名为<code>owner</code>(小写，未导出)的字段，则getter方法应称为<code>Owner</code>(大写，导出)，而不是<code>GetOwner</code>。使用大写名称进行导出可提供钩子，以将字段与方法区分开。如果需要的话，一个setter函数将被称为<code>SetOwner</code>。这两个名字在实践中都很好理解:</p>
<pre><code class="language-go">owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</code></pre>
<h2 id="接口名称">接口名称</h2>
<p>按照惯例，一种方法的接口使用方法名称加上<code>-er</code>后缀或类似的修饰名来构造代理名词：<code>Reader</code>，<code>Writer</code>，<code>Formatter</code>，<code>CloseNotifier</code>等。</p>
<p>有许多这样的名称，兑现它们和它们捕获的函数名称很有用。<code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>, <code>String</code>等具有规范的签名和含义。为避免混淆，除非您的方法具有相同的签名和含义，否则请不要给它们使用任何名称。相反，如果您的类型实现的方法的含义与熟知类型上的方法的含义相同，请为其赋予相同的名称和签名；调用您的字符串转换器方法<code>String</code>而不是<code>ToString</code>。</p>
<h2 id="mixedcaps">MixedCaps</h2>
<p>最后，Go中的约定是使用<code>MixedCaps</code>或<code>mixedCaps</code>而不是下划线来编写多字名称。</p>
<h1 id="分号">分号</h1>
<p>像C一样，Go的形式语法使用分号来终止语句，但是与C中不同，这些分号不会出现在源代码中。相反，词法分析器使用一条简单的规则在扫描时自动插入分号，因此输入文本几乎没有分号。</p>
<p>规则是这样。如果换行符前的最后一个标记是标识符(包括<code>int</code>和<code>float64</code>之类的单词)，基本文字(例如数字或字符串常量)或其中一个标记</p>
<pre><code class="language-go">break continue fallthrough return ++ -- ) }
</code></pre>
<p>词法分析器总是在标记后插入分号。可以概括为：“如果换行符位于可以结束语句的标记之后，请插入分号”。</p>
<p>也可以在右括号之前省略分号，因此可以使用如下语句:</p>
<pre><code class="language-go">go func() { for { dst &lt;- &lt;-src } }()
</code></pre>
<p>不需要分号。Go一般仅在诸如<code>for</code>循环子句之类的地方具有分号，以分隔初始化程序，条件和延续元素。如果以这种方式编写代码，则在一行上分隔多个语句也是必需的。</p>
<p>分号插入规则的一个后果是，您不能在下一行上放置控件结构的开头括号(<code>if</code>, <code>for</code>, <code>switch</code> or <code>select</code>)。如果这样做，将在分号之前插入一个分号，这可能会导致不想要的效果。像下面这样:</p>
<pre><code class="language-go">if i &lt; f() {
    g()
}
</code></pre>
<p>而并非这样:</p>
<pre><code class="language-go">if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2 - Go: 最佳实践(格式化、注释)]]></title>
        <id>https://whimthen.github.io/post/ts0GeTvyX/</id>
        <link href="https://whimthen.github.io/post/ts0GeTvyX/">
        </link>
        <updated>2020-03-24T04:06:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="引言">引言</h1>
<p>Go作为一门新的编程语言，借鉴了很多语言的想法。Go具有非同寻常的特性，使得在编程上和其他语言有所不同。将<code>C++</code>或<code>Java</code>程序直接转换为Go不太可能产生令人满意的结果-Java程序是用Java而不是Go编写的。另一方面，从Go角度考虑问题可能会成功但完全不同的程序。换句话说，要编写好语言，重要的是要了解它的特性和语法。了解Go变成中已建立的约定(如: 命名、格式、结构等)也很重要，这样编写的程序将易于其他程序员理解。</p>
<p>本章将说明编写清晰、常用的Go语法代码提示。展示了<a href="https://golang.org/ref/spec">语言规范</a>和<a href="https://whimthen.github.io/post/kTvbgt91b/">如何编写Go代码</a>，应该首先阅读这些内容。</p>
<h1 id="格式化">格式化</h1>
<p>格式问题是最有争议但后果最不严重的问题。通常我们可以适应不通的格式样式，但是如果不必这样做会更好，如果每个人都遵循相同的央视，则花费再央视上的时间会更少。问题是如何在没有冗长的说明性风格指南的情况下处理这种理想中的事情。</p>
<p>使用Go，我们可以采用一种不寻常的方法，让机器处理大多数格式化问题。<code>gofmt</code>程序(也可作为<code>go fmt</code>使用，它再程序包级别而不是源文件级别运行)读取Go程序文件，并以锁紧和垂直对齐的标准样式格式化源代码，并保留注释，在必要时重新格式化注释。</p>
<p>例如: 无需花时间对结构字段上的注释进行排列，<code>Gofmt</code>将做到这一点。</p>
<pre><code class="language-go">type T struct {
    name string // name of the object
    value int // its value
}
</code></pre>
<p><code>gofmt</code>使各列对齐后:</p>
<pre><code class="language-go">type T struct {
    name    string // name of the object
    value   int    // its value
}
</code></pre>
<p>标准库中的所有Go代码均已使用gofmt格式化。</p>
<p>一些简短的格式详细信息:</p>
<ul>
<li>缩进: 默认情况下<code>gofmt</code>使用制表符进行缩进，仅在必要时使用空格。</li>
<li>行长度: Go没有行长限制，如果感觉太长，可以将其包裹起来并用制表符缩进。</li>
<li>括号: Go需要的括号比C和Java的更少，控制语句(if, for, switch)的语法中没有括号。而且运算符优先级层次更短更清晰，因此<code>x&lt;&lt;8 + y&lt;&lt;16</code>表示空格意味什么，与其他语言不同。</li>
</ul>
<h1 id="注释">注释</h1>
<p>Go提供了C样式的<code>/* */</code>块注释和C++样式的<code>//</code>行注释。行注释很平常，块注释主要用于程序包注释，但在表达式中很有用，或者禁用大量代码。</p>
<p><code>godoc</code>可以处理Go源文件以提取有关软件包内容的文档。在顶级声明之前出现的注释(没有中间换行符)与声明一起被提取，以用作该项目的解释行文本。这些注释的性质和样式决定了godoc生成的文档的质量。</p>
<p>每个包都应该在<code>package</code>声明之前有一个包注释(块注释)。对于多个文件包，包注释仅需要出现在一个文件中，任何一个都可以。包注释应该介绍该包，并提供与该包有关的信息。它会出现在godoc页面上，应及时设置详细文档。</p>
<pre><code class="language-go">/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
</code></pre>
<p>如果包很简单，则包注释可以使用行注释:</p>
<pre><code class="language-go">// Package path implements utility routines for
// manipulating slash-separated filename paths.
package comment
</code></pre>
<p>注释不需要额外的格式，例如星号标识。生成的注释甚至不会以固定宽度的字体显示，因此不需要以来对齐间距。<code>godoc</code>(例如: <code>gofmt</code>)会处理这些问题。注释是未经解释的纯文本，因此HTML和其他注释（如<code>_this_</code>）将逐字复制，因此不应使用。godoc所做的一种调整是以固定宽度的字体显示缩进的文本，适用于程序片段。</p>
<p>根据上下文的不同，godoc可能甚至不会重新格式化注释，因此请确保它们看起来直截了当: 使用正确的拼写，标点和句子结构，折叠长行等。</p>
<p>在包中，顶级声明之前的任何注释都将用作该声明的文档注释。程序中的每个导出(大写)名称都应带有文档注释。</p>
<p>Doc注释最好作为完整的句子使用，它可以进行各种各样的自动演示。第一句应为单句摘要，以声明的名称开头。</p>
<pre><code class="language-go">// Compile parses a regular expression and returns, if successful,
// a Regexp that can be used to match against text.
func Compile(str string) (*Regexp, error) {
</code></pre>
<p>如果每个文档注释都以其描述的项目名称开头，则可以使用go工具的doc子命令并通过grep运行输出。想象一下，您忘记了名称&quot;Compile&quot;，但正在寻找正则表达式的解析函数，因此您运行了命令:</p>
<pre><code class="language-shell">$ go doc -all regexp | grep -i parse
</code></pre>
<p>如果包中的所有文档注释均以&quot;This function...&quot;开头，则grep不会帮助您记住该名称。但是，因为该软件包以每个文档注释的名称开头，所以您会看到类似这样的内容，会记住您要查找的单词。</p>
<pre><code class="language-shell">$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
$
</code></pre>
<p>Go的声明语法允许对声明进行分组。单个文档注释可以引入一组相关的常量或变量。由于整个声明都已表达，因此这样的注释常常是含糊的。</p>
<pre><code class="language-go">// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New(&quot;regexp: internal error&quot;)
    ErrUnmatchedLpar = errors.New(&quot;regexp: unmatched '('&quot;)
    ErrUnmatchedRpar = errors.New(&quot;regexp: unmatched ')'&quot;)
    ...
)
</code></pre>
<p>分组还可以指示项目之间的关系，例如一组变量受互斥锁保护的事实。</p>
<pre><code class="language-go">var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.1 - Go: 如何编写Go代码]]></title>
        <id>https://whimthen.github.io/post/kTvbgt91b/</id>
        <link href="https://whimthen.github.io/post/kTvbgt91b/">
        </link>
        <updated>2020-03-23T07:34:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>本文档演示了模块内部简单Go软件包的开发，并介绍了<a href="https://golang.org/cmd/go/">go工具</a>，这是获取，构建和安装Go模块，软件包和命令的标准方法。<br>
<strong>注意:</strong> 本文档使用的是Go 1.13或更高版本，并且未设置<code>GO111MODULE</code>环境变量。如果使用更低版本Go，请查看<a href="https://golang.org/doc/gopath_code.html">官方文档</a>。</p>
<h1 id="组织代码">组织代码</h1>
<p>Go程序用包来组织代码。包是在同一目录中一起编译的源文件的集合。在一个go源文件中定义的函数，类型，变量和常量对于同一包中的所有其他源文件可见。</p>
<p>存储库包含一个或多个模块。模块是一起发布的相关Go软件包的集合。Go存储库通常仅包含一个模块，该模块位于存储库的根目录。<code>go.mod</code>文件中声明了<code>模块路径</code>: 模块内所有软件包的倒入路径前缀。该模块将软件包包含在包含其<code>go.mod</code>文件的目录以及该目录的子目录中，直至包含另一个<code>go.mod</code>文件（如果有）的下一个子目录。</p>
<p>请注意，在构建代码之前，无需将代码发布到远程存储库。可以在本地定义模块，而不必属于存储库。但是，组织代码是一种好习惯，就像您有一天要发布代码一样。</p>
<p>每个模块的路径不仅充当其软件包的导入路径前缀，而且还指示go命令将其下载到的位置。例如，为了下载模块<code>golang.org/x/tools</code>，go命令将查询<code>https://golang.org/x/tools</code>所指示的存储库(<a href="https://golang.org/cmd/go/#hdr-Relative_import_paths">此处有更多说明</a>)。</p>
<p>导入路径是用于导入软件包的字符串。包的导入路径是其模块路径及其在模块中的子目录。例如: 模块<code>github.com/google/go-cmp</code>在目录<code>cmp/</code>中包含一个包。该包的倒入路径为<code>github.com/google/go-cmp/cmp</code>。标准库中的包没有模块路径前缀。</p>
<h1 id="第一个程序">第一个程序</h1>
<p>要编译并运行一个程序，首先选择一个模块路径(例如: <code>example.com/user/hello</code>)，然后创建一个声明它的<code>go.mod</code>文件。</p>
<pre><code class="language-shell">$ mkdir hello
$ cd hello
$ go mod init example.com/user/hello
go: creating new go.mod: module example.com/user/hello
$ cat go.mod
module example.com/user/hello

go 1.14
$
</code></pre>
<p>Go源文件中的第一条语句必须是程序包名称。可执行命令必须始终使用包<code>main</code>。<br>
接下来，在该目录中创建一个名为<code>hello.go</code>的文件，其中包含以下Go代码:</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello, world.&quot;)
}
</code></pre>
<p>现在可以使用go工具编译并安装程序:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<p>该命令生成名为<code>hello</code>的可执行二进制文件。然后，将该二进制文件安装为<code>$HOME/go/bin/hello</code>(或在Windows下为<code>%USERPROFILE%\go\bin\hello.exe</code>)。</p>
<p>安装路径取决于<a href="">环境变量</a><code>GOPATH</code>和<code>GOBIN</code>。如果设置了<code>GOBIN</code>，则二进制文件被安装在此目录中。如果设置了<code>GOPATH</code>，二进制文件被安装到<code>GOPATH</code>列表中第一个目录的<code>bin</code>子目录中。除此以外，二进制文件被安装到默认的<code>GOPATH</code>(<code>$HOME/go</code>或<code>%USERPROFILE%\go</code>)的<code>bin</code>子目录中。</p>
<p>您可以使用<code>go env</code>命令为以后的go命令可移植地设置环境变量的默认值:</p>
<pre><code class="language-shell">$ go env -w GOBIN=/somewhere/else/bin
</code></pre>
<p>要取消设置先前由<code>go env -w</code>设置的变量，请使用<code>go env -u</code>:</p>
<pre><code class="language-shell">$ go env -u GOBIN
</code></pre>
<p>像<code>go install</code>之类的命令适用于包含当前工作目录的模块的上下文。如果工作目录不在<code>example.com/user/hello</code>模块内，则安装可能失败。</p>
<p>为了方便起见，go命令接受相对于工作目录的路径，如果没有其他路径，则默认使用当前工作目录中的软件包。<br>
因此，在我们的工作目录中，以下命令都是等效的:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<pre><code class="language-shell">$ go install .
</code></pre>
<pre><code class="language-shell">$ go install
</code></pre>
<p>接下来，运行程序以确保可以正常工作。为了方便程序的运行，通常将安装目录添加到环境变量<code>PATH</code>中，使运行二进制文件变的更加简单:</p>
<pre><code class="language-shell"># Windows用户应查阅 https://github.com/golang/go/wiki/SettingGOPATH
# 设置%PATH%变量.
$ export PATH=$PATH:$(dirname $(go list -f '{{.Target}}' .))
$ ./hello
Hello, world.
</code></pre>
<p>如果你是用版本管理系统，现在是初始化仓库的最好时机。添加并提交你的第一次修改。再一次说明: 这是不是必须的，完全可以使用本地模块。</p>
<pre><code class="language-shell">$ git init
Initialized empty Git repository in /home/user/hello/.git/
$ git add go.mod hello.go
$ git commit -m &quot;initial commit&quot;
[master (root-commit) 0b4507d] initial commit
 1 file changed, 7 insertion(+)
 create mode 100644 go.mod hello.go
</code></pre>
<p>go命令通过请求相应的HTTPS URL并读取HTML响应中嵌入的元数据来查找包含给定模块路径的存储库(请参阅<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths">go help importpath</a>)。许多托管服务已经为包含Go代码的存储库提供了该元数据，因此使您的模块可供其他人使用的最简单方法通常是使其模块路径与存储库的URL相匹配。</p>
<h1 id="在你的模块中导入包">在你的模块中导入包</h1>
<p>编写一个<code>morestrings</code>包，并在<code>hello</code>程序中使用它。首先创建一个名为<code>$HOME/hello/morestrings</code>的目录，然后在该目录中创建一个名为<code>reverse.go</code>的文件，包含以下内容:</p>
<pre><code class="language-go">// 包morestrings实现了其他功能来操纵UTF-8
// 编码的字符串，超出标准“字符串”包中提供的字符串。
package morestrings

// ReverseRunes 返回其参数字符串，从左向右以符文方向反转。
func ReverseRunes(s string) string {
	r := []rune(s)
	for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
	return string(r)
}
</code></pre>
<p>因为<code>ReverseRunes</code>以大些字符开头，它意味着是<a href="https://golang.org/ref/spec#Exported_identifiers">可导出</a>的。并可以在导入morestrings软件包的其他软件包中使用。</p>
<p>让我们测试一下该软件包可以通过<code>go build</code>编译:</p>
<pre><code class="language-shell">$ cd $HOME/hello/morestrings
$ go build
</code></pre>
<p>这不会产生输出文件。而是将已编译的程序包保存在本地构建缓存中。</p>
<p>确认<code>morestrings</code>包构建后，在<code>hello</code>中使用，修改原始的<code>$HOME/hello/hello.go</code>来使用:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;example.com/user/hello/morestrings&quot;
)

func main() {
	fmt.Println(morestrings.ReverseRunes(&quot;!oG ,olleH&quot;))
}
</code></pre>
<p>安装<code>hello</code>程序:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
</code></pre>
<p>运行新版本的程序，应该可以看到一条新的反向消息:</p>
<pre><code class="language-shell">$ hello
Hello, Go!
</code></pre>
<h1 id="从远程模块导入包">从远程模块导入包</h1>
<p>导入路径可以描述如何使用版本控制系统(如<code>Git</code>或<code>Mercurial</code>)获取软件包源代码。go工具使用此属性来自动从远程存储库获取软件包。例如，要在程序中使用<code>github.com/google/go-cmp/cmp</code>:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;example.com/user/hello/morestrings&quot;
	&quot;github.com/google/go-cmp/cmp&quot;
)

func main() {
	fmt.Println(morestrings.ReverseRunes(&quot;!oG ,olleH&quot;))
	fmt.Println(cmp.Diff(&quot;Hello World&quot;, &quot;Hello Go&quot;))
}
</code></pre>
<p>当您运行诸如<code>go install</code>，<code>go build</code>或<code>go run</code>之类的命令时，go命令将自动下载远程模块并将其版本记录在<code>go.mod</code>文件中:</p>
<pre><code class="language-shell">$ go install example.com/user/hello
go: finding module for package github.com/google/go-cmp/cmp
go: downloading github.com/google/go-cmp v0.4.0
go: found github.com/google/go-cmp/cmp in github.com/google/go-cmp v0.4.0
$ hello
Hello, Go!
  string(
- 	&quot;Hello World&quot;,
+ 	&quot;Hello Go&quot;,
  )
$ cat go.mod
module example.com/user/hello

go 1.14

require github.com/google/go-cmp v0.4.0
</code></pre>
<p>模块依赖项将自动下载到<code>GOPATH</code>环境变量指示的目录的<code>pkg/mod</code>子目录中。给定版本的模块的下载内容在需要该版本的所有其他模块之间共享，因此go命令将这些文件和目录标记为只读。<br>
要删除所有下载的模块，可以传递<code>-modcache</code>标志进行清理:</p>
<pre><code class="language-shell">$ go clean -modcache
</code></pre>
<h1 id="测试">测试</h1>
<p>Go具有由<code>go test</code>命令和测试包组成的轻量级测试框架。</p>
<p>通过创建一个名称以<code>_test.go</code>结尾的文件来编写测试，该文件包含名为<code>TestXXX</code>且具有签名<code>func (t * testing.T)</code>的函数。测试框架运行每个这样的功能。如果该函数调用诸如<code>t.Error</code>或<code>t.Fail</code>之类的失败函数，则认为测试已失败。</p>
<p>创建<code>$HOME/hello/morestrings/reverse_test.go</code>文件，并将以下代码添加到其中:</p>
<pre><code class="language-go">package morestrings

import &quot;testing&quot;

func TestReverseRunes(t *testing.T) {
  	cases := []struct {
  		  in, want string
  	}{
    		{&quot;Hello, world&quot;, &quot;dlrow ,olleH&quot;},
    		{&quot;Hello, 世界&quot;, &quot;界世 ,olleH&quot;},
    		{&quot;&quot;, &quot;&quot;},
  	}
  	for _, c := range cases {
    		got := ReverseRunes(c.in)
    		if got != c.want {
    			  t.Errorf(&quot;ReverseRunes(%q) == %q, want %q&quot;, c.in, got, c.want)
    		}
  	}
}
</code></pre>
<p>然后使用<code>go test</code>运行测试:</p>
<pre><code class="language-shell">$ go test
PASS
ok  	example.com/user/morestrings 0.165s
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1 - Go: 安装]]></title>
        <id>https://whimthen.github.io/post/getting-started-1/</id>
        <link href="https://whimthen.github.io/post/getting-started-1/">
        </link>
        <updated>2020-03-23T03:22:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>下载和安装Go编译器，工具和库的说明</p>
</blockquote>
<h1 id="下载go发行版">下载Go发行版</h1>
<p><a href="https://golang.org/dl/">转到下载页面</a><br>
官方二进制发行版适用于FreeBSD(10-STABLE及更高版本)，Linux，macOS(10.10及更高版本)和Windows操作系统以及32位(386)和64位(amd64)x86处理器架构。<br>
如果二进制发行版不适用于您的操作系统和架构的组合，请尝试从<a href="https://golang.org/doc/install/source">源代码安装</a>或<a href="https://golang.org/doc/install/gccgo">安装gccgo</a>而不是gc。</p>
<h1 id="系统要求">系统要求</h1>
<p>Go二进制发行版可用于这些受支持的操作系统和系统架构。在继续操作之前，请确保您的系统满足这些要求。</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作系统</th>
<th style="text-align:center">系统架构</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FreeBSD 10.3或更高版本</td>
<td style="text-align:center">amd64, 386</td>
<td style="text-align:left">Debian GNU/kFreeBSD不支持</td>
</tr>
<tr>
<td style="text-align:left">Linux 2.6.23或更高版本(带有glibc)</td>
<td style="text-align:center">amd64, 386, arm, arm64, s390x, ppc64le</td>
<td style="text-align:left">CentOS/RHEL 5.x不支持。需要从源码安装或其他的libc。</td>
</tr>
<tr>
<td style="text-align:left">macOS 10.10或更高版本</td>
<td style="text-align:center">amd64</td>
<td style="text-align:left">使用Xcode<sup>2</sup>提供的clang或gcc<sup>1</sup>支持<code>cgo</code></td>
</tr>
<tr>
<td style="text-align:left">Windows 7, Server 2008R2或更高版本</td>
<td style="text-align:center">amd64, 386</td>
<td style="text-align:left">使用MinGW(386)或MinGW-W64(amd64)提供gcc<sup>1</sup>。不需要<code>cygwin</code>或<code>msys</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>1: 仅当计划使用<a href="https://golang.org/cmd/cgo">cgo</a>时，才需要C编译器。<br>
2: 只需要为Xcode安装命令行工具。如果已经安装了<a href="https://developer.apple.com/Xcode/">Xcode</a>4.3+，则可以从&quot;下载&quot;首选项面板的&quot;组件&quot;选项卡中进行安装。</p>
</blockquote>
<h1 id="安装go工具">安装Go工具</h1>
<p>如果要从旧版Go升级，则必须先删除现有版本。</p>
<h1 id="linux-macos和freebsd压缩包">Linux, macOS和FreeBSD压缩包</h1>
<p><a href="https://golang.org/dl/">下载存档文件</a>并解压到<code>/usr/local</code></p>
<pre><code class="language-shell">$ tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz
</code></pre>
<p>选择适合你自己的存档文件。例如：如果你要在Linux上为64位x86安装<code>Go1.2.1</code>版本。则存档文件的名称应该是<code>go1.2.1.linux-amd64.tar.gz</code></p>
<blockquote>
<p>通常，这些命令必须以root用户或通过sudo运行</p>
</blockquote>
<p>将<code>/usr/local/go/bin</code>添加到系统环境变量中。或执行以下命令添加到<code>/etc/profile</code>或<code>$HOME/.profile</code></p>
<pre><code class="language-shell">$ export PATH=$PATH:/usr/local/go/bin
</code></pre>
<p><strong>注意:</strong> 修改配置文件可能需要等到下次重启系统才会生效。要立即应用更改，只需要直接运行shell命令或使用如<code>source ~/.profile</code>之类的命令。</p>
<h1 id="macos包安装器">macOS包安装器</h1>
<p><a href="https://golang.org/dl/">下载包文件</a>，打开并根据提示安装Go工具，该软件包将安装Go发行版到<code>/usr/local/go</code></p>
<p>该软件包需要将<code>/usr/local/go/bin</code>目录添加到系统环境变量中，你可能需要重新启动所有打开的终端会话以使更改生效。</p>
<h1 id="windows">Windows</h1>
<p>Go为Windows用户提供两种安装方式</p>
<ul>
<li><a href="https://golang.org/doc/install/source">源码安装</a>: 一个<code>zip</code>压缩包，必须设置一些环境变量</li>
<li><code>MSI安装器</code>: 使用该方式安装将自动配置</li>
</ul>
<h3 id="msi安装器">MSI安装器</h3>
<p>打开<a href="https://golang.org/dl/">MSI文件</a>并根据提示安装Go工具。默认将Go发行版安装到<code>c:/Go</code><br>
该安装器将<code>c:/Go/bin</code>目录放在系统环境变量中，你可能需要重启所有打开的命令行终端，以使更改生效。</p>
<h3 id="zip压缩包">Zip压缩包</h3>
<p><a href="https://golang.org/dl/">下载压缩包文件</a>并解压到指定目录。(建议使用: <code>c:/Go</code>)<br>
添加<code>bin</code>子目录到系统环境变量中(如: <code>c:/Go/bin</code>)</p>
<h3 id="在windows下设置环境变量">在Windows下设置环境变量</h3>
<p>在Windows下，您可以通过“系统”控制面板的“高级”选项卡上的“环境变量”按钮设置环境变量。Windows的某些版本通过“系统”控制面板中的“高级系统设置”选项提供此控制面板</p>
<h1 id="测试安装">测试安装</h1>
<p>使用一个简单的程序检查Go是否安装正确<br>
创建一个以<code>hello.go</code>命名的文件</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Printf(&quot;hello, world\n&quot;)
}
</code></pre>
<p>然后使用Go工具编译</p>
<pre><code class="language-shell">$ go build hello.go
</code></pre>
<p>上面的命令将在源代码旁边的当前目录中构建一个名为hello的可执行文件。执行以查看结果。</p>
<pre><code class="language-shell">$ ./hello
hello, world
</code></pre>
<p>如果你能看到&quot;hello, world&quot;消息说明安装成功</p>
<h1 id="安装额外的go版本">安装额外的Go版本</h1>
<p>在同一台计算机上安装多个Go版本可能很有用，例如，以确保软件包的测试可以通过多个Go版本。一旦安装了一个Go版本，就可以如下安装另一个版本(例如1.10.7)</p>
<pre><code class="language-shell">$ go get golang.org/dl/go1.10.7
$ go1.10.7 download
</code></pre>
<p>新下载的版本可以像go一样使用:</p>
<pre><code class="language-shell">$ go1.10.7 version
go version go1.10.7 linux/amd64
</code></pre>
<p><a href="https://godoc.org/golang.org/dl#pkg-subdirectories">下载页面</a>上列出了通过此方法可用的所有Go版本。您可以通过查看其GOROOT来找到这些额外的Go版本的安装位置。例如<code>go1.10.7 env GOROOT</code>。要卸载下载的版本，只需删除其GOROOT目录和goX.Y.Z二进制文件</p>
<h1 id="卸载go">卸载Go</h1>
<p>要从系统中删除现有的Go安装，请删除go目录。<br>
在Linux，macOS和FreeBSD下通常为<code>/usr/local/go</code>，在Windows下通常为<code>c:/Go</code><br>
您还应该从PATH环境变量中删除Go bin目录。<br>
在Linux和FreeBSD下，您应该编辑<code>/etc/profile</code>或<code>$HOME/.profile</code>。<br>
如果您使用macOS软件包安装了Go，则应删除<code>/etc/paths.d/go</code>文件。<br>
Windows用户应阅读有关在Windows下设置环境变量的部分。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NIO 中需要注意⚠️的事项]]></title>
        <id>https://whimthen.github.io/post/nio_notice/</id>
        <link href="https://whimthen.github.io/post/nio_notice/">
        </link>
        <updated>2020-03-18T07:24:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="处理事件忘记移除key">处理事件忘记移除key</h1>
<p>在select返回值大于0的情况下，循环处理Selector.selectedKeys集合，每处理一个必须从Set中移除<br>
<font color="red">不移除的后果是本次的就绪的key集合下次会再次返回,导致无限循环，CPU消耗100%</font></p>
<pre><code class="language-java">Iterator&lt;SelectionKey&gt; it=set.iterator();
    While(it.hasNext()){
    SelectionKey key=it.next();
    it.remove(); //切记移除
    // 处理事件......
}
</code></pre>
<h1 id="selector-返回的-key-集合非线程安全">Selector 返回的 key 集合非线程安全</h1>
<ul>
<li>Selector.selectedKeys/keys 返回的集合都是非线程安全的</li>
<li>Selector.selectedKeys返回的可移除</li>
<li>Selector.keys 不可变</li>
<li>对selected keys的处理必须单线程处理或者适当同步</li>
</ul>
]]></content>
    </entry>
</feed>